#!/usr/bin/env false bash

if [[ $- != *i* ]]; then
  source_once &> /dev/null && return 0
fi

source "$(dirname "${BASH_SOURCE[0]}")/findin"
source "$(dirname "${BASH_SOURCE[0]}")/colors.bsh"
source "$(dirname "${BASH_SOURCE[0]}")/set_flags.bsh"
source "$(dirname "${BASH_SOURCE[0]}")/real_path"

CSI=$'\x1b['
: ${_debug_prompt='$ '}
: ${_debug_L_file_color="$(FG_24 86 156 214)"}
: ${_debug_L_function_color="$(FG_24 220 220 170)"}
: ${_debug_L_line="$(FG_24 156 220 254)"}
: ${_debug_L_current_line="${LIGHT_GREEN}"}

# :Arguments: ``[$1]`` - By default outputs to 2, but if you redirects stderr,
#                        you can specify a different fd to output to
function set_trace()
{
  unset_flags x v
  echo -n "${NC}"
  local -i _debug_stack_level=1
  local _debug_stdout
  local _debug_input
  local -i _debug_history_index
  local _debug_history_found
  local _debug_history=()
  local -i _debug_prompt_offset=${#_debug_prompt}+1

  # Load History
  : ${JUST_DEBUG_HISTORY=~/.debug_bash_history}
  : ${JUST_DEBUG_HISTORY_LENGTH=1000}
  if [[ -e ${JUST_DEBUG_HISTORY} ]]; then
     while IFS= read -rd '' _debug_input || [ -n "${_debug_input}" ]; do
       _debug_history+=("$_debug_input")
     done < "${JUST_DEBUG_HISTORY}"
  fi
  _debug_history_index="${#_debug_history[@]}"
  _debug_input=''

  # Copy stdout
  if [ "${BASH_VERSINFO[0]}${BASH_VERSINFO[1]}" -ge "41" ]; then
    exec {_debug_stdout}>&1
  else
    find_open_fd _debug_stdout
    eval "exec ${_debug_stdout}>&1"
  fi
  # Make stdout messages go to stderr. This way if you are debugging in a "$(blah)"
  # then the output from debugging won't break the main script
  exec 1>&${1-2}

  # REPL loop
  while _trace_repl ; do
    # Add new line to the history buffer
    if [[ -n ${_debug_input} ]]; then
      _debug_history_found="$(findin "${_debug_input}" "${_debug_history[@]}")"
      if [[ ${_debug_history_found} != -1 ]]; then
        _debug_history=("${_debug_history[@]::_debug_history_found}"
                        "${_debug_history[@]:_debug_history_found+1}"
                        "${_debug_input}")
      else
        _debug_history+=("${_debug_input}")
      fi
      _debug_history_index=${#_debug_history[@]}
    fi
  done

  # Restore stdout, and close copy
  exec 1>&${_debug_stdout}
  if [ "${BASH_VERSINFO[0]}${BASH_VERSINFO[1]}" -ge "41" ]; then
    exec {_debug_stdout}>&-
  else
    eval "${_debug_stdout}>&-"
  fi

  # Save history
  _trace_save_history
  reset_flags x v
}

function _set_trace_next()
{
  : trap -- DEBUG
  # set_trace
  # This needs to be smarter, it needs to say "If not in debug, at the same stack, then set_trace
  # I can do the same for step in
}

function _trace_enable_debug_trap()
{
  trap _set_trace_next DEBUG
}

function _trace_save_history()
{
  local -i index=${#_debug_history[@]}-${JUST_DEBUG_HISTORY_LENGTH}
  if [[ ${index} -lt 0 ]]; then
    index=0
  fi
  set -xv
  _debug_history=(${_debug_history[@]+"${_debug_history[@]:index}"})

  if [[ ${#_debug_history[@]} -ge 1 ]]; then
    mkdir -p "$(dirname "${JUST_DEBUG_HISTORY}")"
    echo -n "${_debug_history[0]}" > "${JUST_DEBUG_HISTORY}"
    if [[ ${#_debug_history[@]} -gt 1 ]]; then
      printf '\0%s' "${_debug_history[@]:1}" >> "${JUST_DEBUG_HISTORY}"
    fi
  fi
}

# I tried using coproc and "tput -S >in_pipe <out_pipe &" with
# 'exec 3> "${in_data}" 4< "${out_data}"', but that buffers TOO!?
# Only universal solution left is to wrap a simple wrapper in python/perl, that
# will continuously open a close stdin/stdout, so I can "echo cols > in_data",
# without using the fd and exec trick. However forcing unbuffered there too
# proved too difficult. "python -u" does not work, "stdbuf -o0" does, but it
# only exists on Linux

function _trace_get_cols()
{
  echo "$(tput cols)"
}

function _trace_read()
{
  # History, null separated file in Home dir

  # simple way
  # read -rp "${_debug_prompt}" _debug_input
  local line=''
  local lines=()
  local key=''
  local -i index=0
  local tmp
  local -i calc1
  LOCALE=C
  LC_ALL=C
  echo -n "${_debug_prompt}"

  local breakpoint_lines=()
  local breakpoint_files=()
  local breakpoint_conditions=()

  local window_width="$(tput cols)"
  while :; do
    IFS= read -d '' -rsn1 key
    case "${key}" in
      $'\x1b') # Esc or beginning of arrow sequences
        IFS= read -d '' -rsn1 key
        case "${key}" in
          O) # F1-F4
            IFS= read -d '' -rsn1 key
            ;;
          $'\n') # Alt+Enter
            line="${line%\\}"$'\n'
            lines+=("${line}")
            line=''
            index=0
            echo
            printf "%$((_debug_prompt_offset-1))s" ''
            ;;
          '[') # ANSI CSI
            local parameter=''
            local intermediate=''
            # local ansi_stage=2 #0=1b, 1=5b, 2=30-3f, 3=20-2f, 4=40-7f # Don't care
            while :; do
              IFS= read -d '' -rsn1 key
              case "${key}" in
                [$'\x30'-$'\x3f'])
                  # if [[ ${ansi_stage} -le 2 ]; then # Don't care
                    parameter+="${key}"
                  # else # Don't care
                  #   break # Don't care
                  # fi # Don't care
                  ;;
                [$'\x20'-$'\x2f'])
                  ansi_stage=3
                  intermediate+="${key}"
                  ;;
                [$'\x40'-$'\x7f'])
                  break
                  ;;
                *)
                  continue 2
                  ;;
              esac
            done
            case "${key}" in  # Final byte"
              $'\x41') # Up
                if [[ ${_debug_history_index} -gt 0 ]]; then
                  _debug_history_index=_debug_history_index-1
                  line="${_debug_history[_debug_history_index]}"
                  echo -n "${CSI}2K${CSI}0E${_debug_prompt}${line}"
                  index="${#line}"
                fi
                ;;
              $'\x42') # Down
                if [[ ${_debug_history_index} -ge ${#_debug_history[@]} ]]; then
                  line=""
                else
                  _debug_history_index+=1
                  line="${_debug_history[_debug_history_index]}"
                fi
                echo -n "${CSI}2K${CSI}0E${_debug_prompt}${line}"
                index="${#line}"
                ;;
              $'\x43') # Right
                if [[ ${index} -lt ${#line} ]]; then
                  echo -n "${CSI}1C"
                  index+=1
                fi
                ;;
              $'\x44') # Left
                if [[ ${index} -gt 0 ]]; then
                  echo -n "${CSI}1D"
                  index=${index}-1
                fi
                ;;
              $'\x48') # Home
                echo home > /tmp/tmp
                echo -n "${CSI}${_debug_prompt_offset}G"
                index=0
                ;;
              $'\x46') # End
                echo end $((_debug_prompt_offset+index)) >> /tmp/tmp
                echo -n "${CSI}$((_debug_prompt_offset+index))G"
                index="${#line}"
                ;;
              $'\x7e') # Delete
                if [[ ${#line} -gt 0 && ${index} -lt ${#line} ]]; then
                  calc1=${#line}-${index}-1
                  line="${line::index}${line:index+1}"
                  echo -n $'\x1b[0K'"${line:index}"$'\x1b['"${calc1}D"
                  index=${index}
                fi
                ;;
            esac
            ;;
        esac

        # F1-F4 are special
        # 1b + 5b + 30-3f * x + 20-2f * x + 40-7f

        # 1b5b5a Shift+Tab

        # 1b5b41 Up
        # 1b5b313b3241 Shift+Up
        # 1b5b313b3341 Alt+Up
        # 1b5b313b3441 Alt+Shift+Up
        # 1b5b313b3541 Ctrl+Up
        # 1b5b42 Down
        # 1b5b43 Right
        # 1b5b313b3643 Ctrl+Shift+Right
        # 1b5b44 Left
        # 1b5b45 *Num Pad center  1b5b47
        # 1b5b327e Insert
        # 1b5b337e Delete
        # 1b5b48 Home
        # 1b5b313b3748 Alt+Ctrl+Home
        # 1b5b46 End
        # 1b5b357e Page Up
        # 1b5b367e Page Up

        # F1-F5 are weird in Mingw
        # 1b4f50 F1     1b5b5b41
        # 1b4f51 F2     1b5b5b42
        # 1b4f52 F3     1b5b5b43
        # 1b5b313b3252 Shift+F3
        # 1b5b313b3352 Alt+F3
        # 1b5b313b3452 Alt+Shift+F3
        # 1b5b313b3552 Ctrl+F3
        # 1b5b313b3652 Ctrl+Shift+F3
        # ? Ctrl+Alt 37!
        # 1b5b313b3852 Shift+Ctrl+Alt+F3
        # 1b4f53 F4     1b5b5b44
        # 1b5b31357e F5 1b5b5b45
        # 1b5b31377e F6
        # 1b5b31387e F7
        # 1b5b31397e F8
        # 1b5b32307e F9
        # 1b5b32347e F12

        # Doesn't matter, this is more getting down in the weeds than anything
        # that can be used. Using these will actually accomplish the same as
        # above, so it's not something you should actually parse!
        # Alt+[ is 1b5b

        ;;
      $'\x01') # Ctrl+A
        ;;
      $'\x02') # Ctrl+B
        ;;
      $'\x04') # Ctrl+D
        ;;
      $'\x05') # Ctrl+E
        ;;
      $'\x06') # Ctrl+F
        ;;
      $'\x07') # Ctrl+G
        ;;
      $'\x08') # Ctrl+H
        ;;
      $'\x09') # Tab doesn't work
        ;;
      $'\x0b') # Ctrl+K
        ;;
      $'\x12') # Ctrl+R
        # First I need history
        ;;
      $'\n')
        if [[ ${#line} -gt 0 && ${line:${#line}-1} != '\' ]]; then
          local IFS=$'\n'
          _debug_input="${lines[@]+${lines[*]}}${line}"
          echo
          return
        else
          line="${line%\\}"$'\n'
          lines+=("${line}")
          line=''
          index=0
          echo
          printf "%$((_debug_prompt_offset-1))s" ''
        fi
        ;;
      $'\x7f') # Back space
        if [ "${#line}" -gt 0 ]; then
          if [[ ${index} = ${#line} ]]; then
            echo -n $'\x1b[1D \x1b[1D'
            line="${line::${#line}-1}"
          else
            calc1=${#line}-${index}
            line="${line::index-1}${line:index}"
            echo -n $'\x1b[1D\x1b[0K'"${line:index-1}"$'\x1b['"${calc1}D"
          fi
          index=${index}-1
        fi
        ;;
      *)
        if [[ ${index} = ${#line} ]]; then
          echo -n "${key}"
          line+="${key}"
        else
          calc1=${#line}-${index}
          line="${line::index}${key}${line:index}"
          echo -n $'\x1b[0K'"${line:index}"$'\x1b['"${calc1}D"
        fi
        index+=1
        ;;
    esac
  done
}

function _trace_repl()
{
  local _debug_rv=0
  _trace_read
  case "${_debug_input}" in
    c)
      return 1
      ;;
    q)
      _trace_save_history
      exit 2
      ;;
    d)
      _debug_stack_level=${_debug_stack_level}-1
      if [[ ${_debug_stack_level} -le 0 ]]; then
        _debug_stack_level=1
      fi
      echo "(${_debug_stack_level}): $(caller ${_debug_stack_level})"
      ;;
    u)
      if caller $((_debug_stack_level + 1)) &> /dev/null; then
        _debug_stack_level+=1
      fi
      echo "(${_debug_stack_level}): $(caller ${_debug_stack_level})"
      ;;
    # n)
    #   trap _set_trace_next DEBUG
    #   return 3
    #   ;;
    l)
      local file="$(caller ${_debug_stack_level})"
      local line_number="${file%% *}"
      file="${file#* }"
      # line_number="$((line_number - 5))"
      local func="${file%% *}"
      file="${file#* }"

      if [[ ${line_number} -lt 0 ]]; then
        line_number=0
      fi

      echo "${_debug_L_file_color}${file}: ${_debug_L_function_color}${func}()${NC}"
      echo
      awk -v "line_number=${line_number}" \
          'BEGIN { line0 = line_number - 3;
                   line1 = line_number + 3;
                   pad = int(log(line1)/log(10))+1
                   pad = sprintf("%%-%dd%%s %%s\n", pad) }
           NR >= line0 && NR <= line1 {
             if (NR == line_number) {
               printf("'"${_debug_L_current_line}"'")
               printf(pad, NR, ">", $0);
             } else {
               printf("'"${_debug_L_line}"'")
               printf(pad, NR, ":", $0);
             }
             if (NR == line1) { exit }
           }
           END {
             printf("\x1b[0m")
            }' "${file}"
      ;;
    t)
      echo 'Traceback'
      echo '---------'

      # Start at one, as to not include set_trace itself
      local -i i=1
      local stack=''
      local line
      while line=("$(caller $i)"); do
        stack+="$(sed $'s| |\t|2' <<< "${line}")"$'\n'
        ((++i))
      done

      if command -v column &> /dev/null; then
        column -c1 -s $'\t' -t <<< "${stack}"
      else
        echo "${stack}"
      fi
      ;;
    p|'p '*)
      local variables=(${_debug_input:2})
      local variable
      # declare -p ${variables[@]+"${variables[@]}"}
      if [[ ${#variables[@]} = 0 ]]; then
        variables=($(compgen -v))
      fi
      for variable in "${variables[@]}"; do
        if [[ $(type -t "${variable}") = function ]]; then
          if [[ ${BASH_VERSINFO[0]}${BASH_VERSINFO[1]} -ge 43 ]]; then
            declare -pf "${variable}"
          else
            type "${variable}"
          fi
        else
          declare -p "${variable}" || : ; echo -n "${CSI}0m"
        fi
      done
      ;;
    e|'e '*)
      _debug_input="${_debug_input:2}"
      if [[ -z ${_debug_input} ]]; then
        return 0
      fi
      _trace_eval
      ;;
    '?'|h)
      echo 'Primitive bash debugger (PBDB)'
      echo '------------------------------'
      echo '?/h - This help messages'
      echo 'c   - Continue execution'
      echo 'd/u - Move down/up the stack. Useful for "l"'
      echo 'l   - Print lines of code'
      echo 'p   - Print variable(s)'
      echo 'e   - Eval statement (default)'
      echo 't   - Print traceback'
      echo 'q   - Quit and exit current bash script'
      ;;
    b)
      echo "Breakpoints"
      echo "-----------"
      for tmp in ${breakpoint_lines[@]+"${!breakpoint_lines[@]}"}; do
        echo "${breakpoint_lines[tmp]}:"$'\t'"${breakpoint_files[tmp]}"
        if [[ ${breakpoint_conditions[tmp]} != '' ]]; then
          echo "    When: ${breakpoint_conditions[tmp]}"
        fi
      done
      _trace_enable_debug_trap
      ;;
    "b "*)
      tmp="${_debug_input#b }"
      breakpoint_lines+=("${tmp%% *}")
      tmp="${tmp#* }"
      local patten='^ *$'
      if [[ tmp =~ ${pattern} ]]; then
        local filename="$(_trace_get_caller_filename ${_debug_stack_level})"
        if [[ ${filename::1} != "/" ]]; then
          filename="$(real_path "${filename}")"
        fi
        breakpoint_files+=("${filename}")
      else
        breakpoint_files+=("${tmp%% *}")
        tmp="${tmp#* }"
      fi

      if [[ tmp =~ ${pattern} ]]; then
        breakpoint_conditions+=('')
      else
        breakpoint_conditions+=("${tmp}")
      fi
      ;;
    *)
      if [[ -z ${_debug_input} ]]; then
        return 0
      fi
      _trace_eval
      ;;
  esac
  return 0
}

function _trace_get_caller_filename()
{
  # Plus one more for this funciton
  local filename="$(caller "$(($1+1))")"
  filename="${filename#* }"
  filename="${filename#* }"
  echo "${filename}"
}

function _trace_eval()
{
  # I have NO idea why I have to do "exec 1>&2;" But I do
  eval "exec 1>&2; set -xv; ${_debug_input}; set +xv" | _debug_rv=$?
  echo "Return: ${_debug_rv}"
}

# Use trace FD to get rid of unwanted stuff, like set +xv