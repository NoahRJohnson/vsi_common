#!/usr/bin/env false bash

if [[ $- != *i* ]]; then
  source_once &> /dev/null && return 0
fi

source "$(dirname "${BASH_SOURCE[0]}")/findin"
source "$(dirname "${BASH_SOURCE[0]}")/colors.bsh"

CSI=$'\x1b['
: ${_debug_prompt='$ '}
: ${_debug_L_file_color="$(FG_24 86 156 214)"}
: ${_debug_L_function_color="$(FG_24 220 220 170)"}
: ${_debug_L_line="$(FG_24 156 220 254)"}
: ${_debug_L_current_line="${LIGHT_GREEN}"}

# :Arguments: ``[$1]`` - By default outputs to 2, but if you redirects stderr,
#                        you can specify a different fd to output to
function set_trace()
{
  set +xv
  echo -n "${NC}"
  local -i _debug_stack_level=1
  local _debug_stdout
  local _debug_input
  local -i _debug_history_index
  local _debug_history_found
  local _debug_history=()
  local -i _debug_prompt_offset=${#_debug_prompt}+1

  # Load History
  : ${JUST_DEBUG_HISTORY=~/.local/share/just/debug_history}
  : ${JUST_DEBUG_HISTORY_LENGTH=1000}
  if [[ -e ${JUST_DEBUG_HISTORY} ]]; then
     while IFS= read -rd '' _debug_input || [ -n "${_debug_input}" ]; do
       _debug_history+=("$_debug_input")
     done < "${JUST_DEBUG_HISTORY}"
  fi
  _debug_history_index="${#_debug_history[@]}"
  _debug_input=''

  # Copy stdout
  if [ "${BASH_VERSINFO[0]}${BASH_VERSINFO[1]}" -ge "41" ]; then
    exec {_debug_stdout}>&1
  else
    find_open_fd _debug_stdout
    eval "exec ${_debug_stdout}>&1"
  fi
  # Make stdout messages go to stderr. This way if you are debugging in a "$(blah)"
  # then the output from debugging won't break the main script
  exec 1>&${1-2}

  # REPL loop
  while _trace_repl ; do
    # Add new line to the history buffer
    if [[ -n ${_debug_input} ]]; then
      _debug_history_found="$(findin "${_debug_input}" "${_debug_history[@]}")"
      if [[ ${_debug_history_found} != -1 ]]; then
        _debug_history=("${_debug_history[@]::_debug_history_found}"
                        "${_debug_history[@]:_debug_history_found+1}"
                        "${_debug_input}")
      else
        _debug_history+=("${_debug_input}")
      fi
      _debug_history_index=${#_debug_history[@]}
    fi
  done

  # Restore stdout, and close copy
  exec 1>&${_debug_stdout}
  if [ "${BASH_VERSINFO[0]}${BASH_VERSINFO[1]}" -ge "41" ]; then
    exec {_debug_stdout}>&-
  else
    eval "${_debug_stdout}>&-"
  fi

  # Save history
  _trace_save_history
}

function _set_trace_next()
{
  trap -- DEBUG
  # set_trace
  # This needs to be smarter, it needs to say "If not in debug, at the same stack, then set_trace
  # I can do the same for step in
}

function _trace_save_history()
{
  local -i index=${#_debug_history[@]}-${JUST_DEBUG_HISTORY_LENGTH}
  if [[ ${index} -lt 0 ]]; then
    index=0
  fi
  set -xv
  _debug_history=(${_debug_history[@]+"${_debug_history[@]:index}"})

  if [[ ${#_debug_history[@]} -ge 1 ]]; then
    mkdir -p "$(dirname "${JUST_DEBUG_HISTORY}")"
    echo -n "${_debug_history[0]}" > "${JUST_DEBUG_HISTORY}"
    if [[ ${#_debug_history[@]} -gt 1 ]]; then
      printf '\0%s' "${_debug_history[@]:1}" >> "${JUST_DEBUG_HISTORY}"
    fi
  fi
}
function _trace_read()
{
  # History, null separated file in Home dir

  # simple way
  # read -rp "${_debug_prompt}" _debug_input
  local line=''
  local key=''
  local -i index=0
  local tmp
  local -i x
  LOCALE=C
  LC_ALL=C
  echo -n "${_debug_prompt}"
  while :; do
    IFS= read -d '' -rsn1 key
    case "${key}" in
      $'\x1b') # Esc or beginning of arrow sequences
        IFS= read -d '' -rsn1 key
        case "${key}" in
          O) # F1-F4
            IFS= read -d '' -rsn1 key
            ;;
          '[') # ANSI CSI
            local parameter=''
            local intermediate=''
            # local ansi_stage=2 #0=1b, 1=5b, 2=30-3f, 3=20-2f, 4=40-7f # Don't care
            while :; do
              IFS= read -d '' -rsn1 key
              case "${key}" in
                [$'\x30'-$'\x3f'])
                  # if [[ ${ansi_stage} -le 2 ]; then # Don't care
                    parameter+="${key}"
                  # else # Don't care
                  #   break # Don't care
                  # fi # Don't care
                  ;;
                [$'\x20'-$'\x2f'])
                  ansi_stage=3
                  intermediate+="${key}"
                  ;;
                [$'\x40'-$'\x7f'])
                  break
                  ;;
                *)
                  continue 2
                  ;;
              esac
            done
            case "${key}" in  # Final byte"
              $'\x41') # Up
                if [[ ${_debug_history_index} -gt 0 ]]; then
                  _debug_history_index=_debug_history_index-1
                  line="${_debug_history[_debug_history_index]}"
                  echo -n "${CSI}2K${CSI}0E${_debug_prompt}${line}"
                  index="${#line}"
                fi
                ;;
              $'\x42') # Down
                if [[ ${_debug_history_index} -ge ${#_debug_history[@]} ]]; then
                  line=""
                else
                  _debug_history_index+=1
                  line="${_debug_history[_debug_history_index]}"
                fi
                echo -n "${CSI}2K${CSI}0E${_debug_prompt}${line}"
                index="${#line}"
                ;;
              $'\x43') # Right
                if [[ ${index} -lt ${#line} ]]; then
                  echo -n "${CSI}1C"
                  index+=1
                fi
                ;;
              $'\x44') # Left
                if [[ ${index} -gt 0 ]]; then
                  echo -n "${CSI}1D"
                  index=${index}-1
                fi
                ;;
              $'\x48') # Home
                echo -n "${CSI}${_debug_prompt_offset}G"
                index=0
                ;;
              $'\x46') # End
                echo -n "${CSI}$((_debug_prompt_offset+index))G"
                index="${#line}"
                ;;
            esac
            ;;
        esac

        # F1-F4 are special
        # 1b + 5b + 30-3f * x + 20-2f * x + 40-7f

        # 1b5b5a Shift+Tab

        # 1b5b41 Up
        # 1b5b313b3241 Shift+Up
        # 1b5b313b3341 Alt+Up
        # 1b5b313b3441 Alt+Shift+Up
        # 1b5b313b3541 Ctrl+Up
        # 1b5b42 Down
        # 1b5b43 Right
        # 1b5b313b3643 Ctrl+Shift+Right
        # 1b5b44 Left
        # 1b5b45 *Num Pad center  1b5b47
        # 1b5b327e Insert
        # 1b5b337e Delete
        # 1b5b48 Home
        # 1b5b313b3748 Alt+Ctrl+Home
        # 1b5b46 End
        # 1b5b357e Page Up
        # 1b5b367e Page Up

        # F1-F5 are weird in Mingw
        # 1b4f50 F1     1b5b5b41
        # 1b4f51 F2     1b5b5b42
        # 1b4f52 F3     1b5b5b43
        # 1b5b313b3252 Shift+F3
        # 1b5b313b3352 Alt+F3
        # 1b5b313b3452 Alt+Shift+F3
        # 1b5b313b3552 Ctrl+F3
        # 1b5b313b3652 Ctrl+Shift+F3
        # ? Ctrl+Alt 37!
        # 1b5b313b3852 Shift+Ctrl+Alt+F3
        # 1b4f53 F4     1b5b5b44
        # 1b5b31357e F5 1b5b5b45
        # 1b5b31377e F6
        # 1b5b31387e F7
        # 1b5b31397e F8
        # 1b5b32307e F9
        # 1b5b32347e F12

        # Doesn't matter, this is more getting down in the weeds than anything
        # that can be used. Using these will actually accomplish the same as
        # above, so it's not something you should actually parse!
        # Alt+[ is 1b5b

        ;;
      $'\x01') # Ctrl+A
        ;;
      $'\x02') # Ctrl+B
        ;;
      $'\x04') # Ctrl+D
        ;;
      $'\x05') # Ctrl+E
        ;;
      $'\x06') # Ctrl+F
        ;;
      $'\x07') # Ctrl+G
        ;;
      $'\x08') # Ctrl+H
        ;;
      $'\x09') # Tab doesn't work
        ;;
      $'\x0b') # Ctrl+K
        ;;
      $'\x12') # Ctrl+R
        # First I need history
        ;;
      $'\n')
        _debug_input="${line}"
        echo
        return
        ;;
      $'\x7f') # Back space
        if [ "${#line}" -gt 0 ]; then
          if [[ ${index} = ${#line} ]]; then
            echo -n $'\x1b[1D \x1b[1D'
            line="${line::${#line}-1}"
          else
            x=${#line}-${index}
            line="${line::index-1}${line:index}"
            echo -n $'\x1b[1D\x1b[0K'"${line:index-1}"$'\x1b['"${x}D"
          fi
          index=${index}-1
        fi
        ;;
      *)
        if [[ ${index} = ${#line} ]]; then
          echo -n "${key}"
          line+="${key}"
        else
          tmp=$((${#line} - ${index}))
          line="${line::index}${key}${line:index}"
          echo -n $'\x1b[0K'"${line:index}"$'\x1b['"${tmp}D"
        fi
        index+=1
        ;;
    esac
  done
}

function _trace_repl()
{
  local _debug_rv=0
  _trace_read
  case "${_debug_input}" in
    c)
      return 1
      ;;
    q)
      _trace_save_history
      exit 2
      ;;
    d)
      _debug_stack_level=${_debug_stack_level}-1
      if [[ ${_debug_stack_level} -le 0 ]]; then
        _debug_stack_level=1
      fi
      echo "(${_debug_stack_level}): $(caller ${_debug_stack_level})"
      ;;
    u)
      if caller $((_debug_stack_level + 1)) &> /dev/null; then
        _debug_stack_level+=1
      fi
      echo "(${_debug_stack_level}): $(caller ${_debug_stack_level})"
      ;;
    # n)
    #   trap _set_trace_next DEBUG
    #   return 3
    #   ;;
    l)
      local file="$(caller ${_debug_stack_level})"
      local line_number="${file%% *}"
      file="${file#* }"
      # line_number="$((line_number - 5))"
      local func="${file%% *}"
      file="${file#* }"

      if [[ ${line_number} -lt 0 ]]; then
        line_number=0
      fi

      echo "${_debug_L_file_color}${file}: ${_debug_L_function_color}${func}()${NC}"
      echo
      awk -v "line_number=${line_number}" \
          'BEGIN { line0 = line_number - 3;
                   line1 = line_number + 3;
                   pad = int(log(line1)/log(10))+1
                   pad = sprintf("%%-%dd%%s %%s\n", pad) }
           NR >= line0 && NR <= line1 {
             if (NR == line_number) {
               printf("'"${_debug_L_current_line}"'")
               printf(pad, NR, ">", $0);
             } else {
               printf("'"${_debug_L_line}"'")
               printf(pad, NR, ":", $0);
             }
             if (NR == line1) { exit }
           }
           END {
             printf("\x1b[0m")
            }' "${file}"
      ;;
    t)
      echo 'Traceback'
      echo '---------'

      # Start at one, as to not include set_trace itself
      local -i i=1
      local stack=''
      local line
      while line=("$(caller $i)"); do
        stack+="$(sed $'s| |\t|2' <<< "${line}")"$'\n'
        ((++i))
      done

      if command -v column &> /dev/null; then
        column -c1 -s $'\t' -t <<< "${stack}"
      else
        echo "${stack}"
      fi
      ;;
    '?')
      echo "Help, coming soon, to a theater near you..."
      ;;
    *)
      if [[ -z ${_debug_input} ]]; then
        return 0
      fi
      # I have NO idea why I have to do "exec 1>&2;" But I do
      eval "exec 1>&2; set -xv; ${_debug_input}; set +xv" | _debug_rv=$?
      echo "Return: ${_debug_rv}"
      ;;
  esac
  return 0
}

# Use trace FD to get rid of unwanted stuff, like set +xv