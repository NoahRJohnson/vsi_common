#!/usr/bin/env false bash

if [[ $- != *i* ]]; then
  source_once &> /dev/null && return 0
fi

source "$(dirname "${BASH_SOURCE[0]}")/findin"

_debug_prompt='$ '

_debug_history=()
function set_trace()
{
  set +xv
  echo -n $'\x1b[0m'
  local -i _debug_stack_level=1
  local _debug_stdout
  local _debug_input=''
  local -i _debug_history_index=0
  local _debug_history_found

  # Copy stdout
  if [ "${BASH_VERSINFO[0]}${BASH_VERSINFO[1]}" -ge "41" ]; then
    exec {_debug_stdout}>&1
  else
    find_open_fd _debug_stdout
    eval "exec ${_debug_stdout}>&1"
  fi
  exec 1>&2

  # REPL loop
  while _trace_repl ; do
    if [[ -n ${_debug_input} ]]; then
      _debug_history_found="$(findin "${_debug_input}" "${_debug_history[@]}")"
      if [[ ${_debug_history_found} != -1 ]]; then
        _debug_history=("${_debug_history[@]::_debug_history_found}"
                        "${_debug_history[@]:_debug_history_found+1}"
                        "${_debug_input}")
      else
        _debug_history+=("${_debug_input}")
      fi
      _debug_history_index=0
    fi
  done

  # Restore stdout, and close copy
  exec 1>&${_debug_stdout}
  if [ "${BASH_VERSINFO[0]}${BASH_VERSINFO[1]}" -ge "41" ]; then
    exec {_debug_stdout}>&-
  else
    eval "${_debug_stdout}>&-"
  fi
}

function _set_trace_next()
{
  trap -- DEBUG
  # set_trace
  # This needs to be smarter, it needs to say "If not in debug, at the same stack, then set_trace
  # I can do the same for step in
}

function _trace_read()
{
  # History, null separated file in Home dir

  # simple way
  # read -rp "${_debug_prompt}" _debug_input
  local line=''
  local key=''
  local -i index=0
  local tmp
  LOCALE=C
  LC_ALL=C
  echo -n "${_debug_prompt}"
  while :; do
    IFS= read -d '' -rsn1 key
    case "${key}" in
      $'\x1b') # Esc or beginning of arrow sequences
        IFS= read -d '' -rsn1 key
        case "${key}" in
          O) # F1-F4
            IFS= read -d '' -rsn1 key
            ;;
          '[') # ANSI CSI
            local parameter=''
            local intermediate=''
            # local ansi_stage=2 #0=1b, 1=5b, 2=30-3f, 3=20-2f, 4=40-7f # Don't care
            while :; do
              IFS= read -d '' -rsn1 key
              case "${key}" in
                [$'\x30'-$'\x3f'])
                  # if [[ ${ansi_stage} -le 2 ]; then # Don't care
                    parameter+="${key}"
                  # else # Don't care
                  #   break # Don't care
                  # fi # Don't care
                  ;;
                [$'\x20'-$'\x2f'])
                  ansi_stage=3
                  intermediate+="${key}"
                  ;;
                [$'\x40'-$'\x7f'])
                  break
                  ;;
                *)
                  continue 2
                  ;;
              esac
            done
            case "${key}" in  # Final byte"
              $'\x41') # Up
declare -p _debug_history_index
                line="${_debug_history[${#_debug_history[@]}-_debug_history_index-1]}"
                if [[ ${#_debug_history[@]} -gt ${_debug_history_index}+1 ]]; then
                  _debug_history_index+=1
                fi
                echo -n $'\x1b[2K\x1b[0E'"${_debug_prompt}${line}"
                index="${#line}"
                ;;
              $'\x42')
declare -p _debug_history_index
                if [[ ${_debug_history_index} -le 0 ]]; then
                  line=""
                else
                  _debug_history_index=_debug_history_index-1
                  line="${_debug_history[${#_debug_history[@]}-_debug_history_index-1]}"
                fi
                index="${#line}"
                echo -n $'\x1b[2K\x1b[0E'"${_debug_prompt}${line}"
                ;;
              $'\x43') # Right
                if [[ ${index} -lt ${#line} ]]; then
                  echo -n $'\x1b[1C'
                  index+=1
                fi
                ;;
              $'\x44') # Left
                if [[ ${index} -gt 0 ]]; then
                  echo -n $'\x1b[1D'
                  index=${index}-1
                fi
                ;;
              $'\x48') # Home
                index=0
                echo -n $'\x1b[3G'
                ;;
              $'\x46') # End
                index="${#line}"
                echo -n $'\x1b['"$((3+index))G"
                ;;
            esac
            ;;
        esac

        # F1-F4 are special
        # 1b + 5b + 30-3f * x + 20-2f * x + 40-7f

        # 1b5b5a Shift+Tab

        # 1b5b41 Up
        # 1b5b313b3241 Shift+Up
        # 1b5b313b3341 Alt+Up
        # 1b5b313b3441 Alt+Shift+Up
        # 1b5b313b3541 Ctrl+Up
        # 1b5b42 Down
        # 1b5b43 Right
        # 1b5b313b3643 Ctrl+Shift+Right
        # 1b5b44 Left
        # 1b5b45 *Num Pad center
        # 1b5b327e Insert
        # 1b5b337e Delete
        # 1b5b48 Home
        # 1b5b313b3748 Alt+Ctrl+Home
        # 1b5b46 End
        # 1b5b357e Page Up
        # 1b5b367e Page Up

        # 1b4f50 F1
        # 1b4f51 F2
        # 1b4f52 F3
        # 1b5b313b3252 Shift+F3
        # 1b5b313b3352 Alt+F3
        # 1b5b313b3452 Alt+Shift+F3
        # 1b5b313b3552 Ctrl+F3
        # 1b5b313b3652 Ctrl+Shift+F3
        # ? Ctrl+Alt 37!
        # 1b5b313b3852 Shift+Ctrl+Alt+F3
        # 1b4f53 F4
        # 1b5b31357e F5
        # 1b5b31377e F6
        # 1b5b31387e F7
        # 1b5b31397e F8
        # 1b5b32307e F9
        # 1b5b32347e F12

        # Doesn't matter, this is more getting down in the weeds than anything
        # that can be used. Using these will actually accomplish the same as
        # above, so it's not something you should actually parse!
        # Alt+[ is 1b5b

        ;;
      $'\x01') # Ctrl+A
        ;;
      $'\x02') # Ctrl+B
        ;;
      $'\x04') # Ctrl+D
        ;;
      $'\x05') # Ctrl+E
        ;;
      $'\x06') # Ctrl+F
        ;;
      $'\x07') # Ctrl+G
        ;;
      $'\x08') # Ctrl+H
        ;;
      $'\x09') # Tab doesn't work
        ;;
      $'\x0b') # Ctrl+K
        ;;
      $'\x12') # Ctrl+R
        # First I need history
        ;;
      $'\n')
        _debug_input="${line}"
        echo
        return
        ;;
      $'\x7f') # Back space
        if [ "${#line}" -gt 0 ]; then
          if [[ ${index} = ${#line} ]]; then
            echo -n $'\x1b[1D \x1b[1D'
            line="${line::${#line}-1}"
          else
            tmp=$((${#line} - ${index}))
            line="${line::index-1}${line:index}"
            echo -n $'\x1b[1D\x1b[0K'"${line:index-1}"$'\x1b['"${tmp}D"
          fi
          index=${index}-1
        fi
        ;;
      *)
        if [[ ${index} = ${#line} ]]; then
          echo -n "${key}"
          line+="${key}"
        else
          tmp=$((${#line} - ${index}))
          line="${line::index}${key}${line:index}"
          echo -n $'\x1b[0K'"${line:index}"$'\x1b['"${tmp}D"
        fi
        index+=1
        ;;
    esac
  done
}

function _trace_repl()
{
  local _debug_rv=0
  _trace_read
  case "${_debug_input}" in
    c)
      return 1
      ;;
    q)
      exit 2
      ;;
    d)
      _debug_stack_level=${_debug_stack_level}-1
      if [[ ${_debug_stack_level} -le 0 ]]; then
        _debug_stack_level=1
      fi
      echo "(${_debug_stack_level}): $(caller ${_debug_stack_level})"
      ;;
    u)
      if caller $((_debug_stack_level + 1)) &> /dev/null; then
        _debug_stack_level+=1
      fi
      echo "(${_debug_stack_level}): $(caller ${_debug_stack_level})"
      ;;
    # n)
    #   trap _set_trace_next DEBUG
    #   return 3
    #   ;;
    l)
      local file="$(caller ${_debug_stack_level})"
      local line_number="${file%% *}"
      file="${file#* }"
      # line_number="$((line_number - 5))"
      local func="${file%% *}"
      file="${file#* }"

      if [[ ${line_number} -lt 0 ]]; then
        line_number=0
      fi

      echo "function ${func}()"
      echo "..."
      # sed -n "${line_number},$((line_number+10))p" "${file}"
      awk 'NR>='"${line_number}"'-5 && NR <= '"${line_number}"'+5 { if (NR=='"${line_number}"') {print "> " $0;} else { print "  " $0 } }' "${file}"
      ;;
    t)
      echo 'Traceback'
      echo '---------'

      # Start at one, as to not include set_trace itself
      local -i i=1
      local stack=''
      local line
      while line=("$(caller $i)"); do
        stack+="$(sed $'s| |\t|2' <<< "${line}")"$'\n'
        ((++i))
      done

      if command -v column &> /dev/null; then
        column -c1 -s $'\t' -t <<< "${stack}"
      else
        echo "${stack}"
      fi
      ;;
    '?')
      echo "Help, coming soon, to a theater near you..."
      ;;
    *)
      if [[ -z ${_debug_input} ]]; then
        return 0
      fi
      # I have NO idea why I have to do "exec 1>&2;" But I do
      eval "exec 1>&2; set -xv; ${_debug_input}; set +xv" | _debug_rv=$?
      echo "Return: ${_debug_rv}"
      ;;
  esac
  return 0
}

# Use trace FD to get rid of unwanted stuff, like set +xv