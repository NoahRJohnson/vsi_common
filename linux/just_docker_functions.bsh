if [[ $- != *i* ]]; then
  source_once &> /dev/null && return 0
fi

JUST_DEFAULTIFY_FUNCTIONS+=(docker_defaultify)
JUST_HELP_FILES+=("${BASH_SOURCE[0]}")

source "${VSI_COMMON_DIR}/linux/docker_functions.bsh"

#*# just/plugins/docker/just_docker_functions

#**
# =========================
# J.U.S.T. Docker Functions
# =========================
#
# .. default-domain:: bash
#
# .. file:: just_docker_functions.bsh
#**

#**
# .. function:: docker-compose_tag_all_stages
#
# :Arguments: - ``$1`` - docker-compose yaml file to use to build service
#             - ``$2`` - Service name to build. This should be the final and unnamed stage
# :Outputs: ``stage_names`` - An array containing the names of the stages taged
# :Parameters: ``JUST_DOCKER_COMPOSE_CACHE_REPO`` - Default value: ``vsiri/ci_cache``
#
# Builds a docker-compose service and tags every named stage found in the Dockerfile, using the names ``${JUST_DOCKER_COMPOSE_CACHE_REPO}:${service_name}_${stage_name}`` with the final stage being tagged ``${JUST_DOCKER_COMPOSE_CACHE_REPO}:final_${stage_name}``
#**
function docker-compose_tag_all_stages()
{
  # Determine dockerfile name from compose file
  local dockerfile="$(yarp < "${1}" | sed -n 's|^services.'"${2}"'.build.dockerfile = ||p')"
  # If blank, it wasn't in the compose file. Use default
  if [ "${dockerfile}" = "" ]; then
    dockerfile=Dockerfile
  fi

  local JUST_DOCKER_COMPOSE_CACHE_REPO
  : ${JUST_DOCKER_COMPOSE_CACHE_REPO=vsiri/ci_cache}

  local number_stages="$(grep -ci ^from "${dockerfile}")"
  local docker_compose_version="$(get_docker_compose_version "${1}")"
  stage_names=($(get_docker_stage_names "${dockerfile}"))
  local stage

  if (( ${#stage_names[@]}+1 != number_stages )); then
    source "${VSI_COMMON_DIR}/linux/colors.bsh"
    echo "${YELLOW}Not all stages are named, they will not all be cached." >&2
    echo "Make sure you name all the stages to cache them all${NC}" >&2
  fi

  local temp_file="$(mktemp)"

  # Build what should be the final image
  Docker-compose -f "${1}" build "${2}" | tee "${temp_file}"
  local final_tag="$(sed -n 's|^Successfully tagged ||p' "${temp_file}")"
  Docker tag "${final_tag}" ${JUST_DOCKER_COMPOSE_CACHE_REPO}:final_${2}

  for stage in ${stage_names[@]+"${stage_names[@]}"}; do
    echo "version: '${docker_compose_version}'" > "${temp_file}"
    echo "services:" >> "${temp_file}"
    echo "  ${2}:" >> "${temp_file}"
    echo "    build:" >> "${temp_file}"
    echo "      target: ${stage}" >> "${temp_file}"
    echo "    image: ${JUST_DOCKER_COMPOSE_CACHE_REPO}:${2}_${stage}" >> "${temp_file}"

    # By adding an override file, any special build flags will be included,
    # such as build args, etc...
    Docker-compose -f "${1}" -f "${temp_file}" build "${2}"
  done

  ${DRYRUN-} rm "${temp_file}"
}

#**
# .. function:: docker-compose_restore_from_cache
#
# :Arguments: - ``$1`` - Docker-compose filename
#             - ``$2`` - Main service name to restore and rebuild
#             - ``[$3...]`` - Addition services based on same dockerfile to restore and rebuild
#
# Restores image from cached images downloaded from the registry.
#**
function docker-compose_restore_from_cache()
{
  local compose_file="${1}"
  shift 1
  # Determine dockerfile name from compose file
  local dockerfile="$(yarp < "${compose_file}" | sed -n 's|^services.'"${1}"'.build.dockerfile = ||p')"
  # If blank, it wasn't in the compose file. Use default
  if [ "${dockerfile}" = "" ]; then
    dockerfile=Dockerfile
  fi

  local JUST_DOCKER_COMPOSE_CACHE_REPO="${JUST_DOCKER_COMPOSE_CACHE_REPO:-vsiri/ci_cache}"

  local stage

  local stage_names=($(get_docker_stage_names "${dockerfile}"))
  Docker pull ${JUST_DOCKER_COMPOSE_CACHE_REPO}:final_${1}
  for stage in ${stage_names[@]+"${stage_names[@]}"}; do
    Docker pull "${JUST_DOCKER_COMPOSE_CACHE_REPO}:${1}_${stage}"
  done

  local temp_file="$(mktemp)"

  local main_service="${1}"

  local docker_compose_version="$(get_docker_compose_version "${compose_file}")"
  while (( $# )); do
    echo   "version: '${docker_compose_version}'" > "${temp_file}"
    echo   "services:" >> "${temp_file}"
    echo   "  ${1}:" >> "${temp_file}"
    echo   "    build:" >> "${temp_file}"
    echo   "      cache_from:" >> "${temp_file}"
    echo   "        - ${JUST_DOCKER_COMPOSE_CACHE_REPO}:final_${main_service}" >> "${temp_file}"
    for stage in ${stage_names[@]+"${stage_names[@]}"}; do
      echo "        - ${JUST_DOCKER_COMPOSE_CACHE_REPO}:${main_service}_${stage}" >> "${temp_file}"
    done

    # By adding an override file, any special build flags will be included,
    # such as build args, etc...
    Docker-compose -f "${compose_file}" -f "${temp_file}" build "${1}"
    shift 1
  done

  ${DRYRUN-} rm "${temp_file}"
}

#**
# .. function:: get_docker_recipes
#
# :Arguments: ``$1...`` - Dockerfiles to search for recipes
# :Parameters: ``JUST_RECIPE_REPO`` - Name of recipe image to look for. Default: ``vsiri/recipe``
# :Output: **stdout** - Newline separated list of the tags of the recipes
#
# Looks for recipes that are used in the dockerfiles.
#**
function get_docker_recipes()
{
  local JUST_RECIPE_REPO="${JUST_RECIPE_REPO-vsiri/recipe}"
  # / and . are the only valid character in an image name that needs regex escaping
  JUST_RECIPE_REPO="${JUST_RECIPE_REPO//./\\.}"
  # Need to escpae / for the first search
  JUST_RECIPE_REPO="${JUST_RECIPE_REPO////\\/}"
  sed -nE '/^ *[fF][rR][oO][mM] *'"${JUST_RECIPE_REPO}"':/{
            s/^ *[fF][rR][oO][mM]  *'"${JUST_RECIPE_REPO}"':([^ ]+).*/\1/
            # Skip (miss) lines with a $ in it, they have variable names that I
            # will not be able to match
            /\$/d
            p
          }' ${@+"${@}"} | sort -u
}

#**
# .. function:: docker_defaultify
#
# .. command:: build_recipes
#
# :Arguments: [``$1``]... - Recipe names to run
#
# Runs ``docker-compose build`` for the docker recipes. Useful command to call before ``docker build`` on your own project that uses recipes in vsi_common, to keep them synced with your build.
#
# .. command:: build_recipes-auto
#
# :Arguments: ``$1``... - Dockerfiles to parse
#
# Scans dockerfiles for ``vsiri/recipe:`` images, and calls :cmd:`build_recipes` on the recipes discovered. Accepts multiple files and ``-`` for stdin
#
# .. command:: log
#
# :Arguments: [``$1``]... - Service names
#
# Show logs from all service containers. Optionally specify service names to only log specific containers.
#
# .. warning::
#
#   Does not pick up containers that didn't exist when starting ``just`` log
#
# Override the log target in your ``Justfile`` and call ``__docker-compose-log`` if you need to set other parameter.
#
# .. command:: docker_clean
#
# :Arguments: ``$1`` - Volume to be removed
#
# Runs ``docker volume rm`` on the specified volume. If the volume is in use, there are four strategies to handle this:
#
# 1. ``ask`` - (default) Interactively asks you if you want to use the stop, delete, or error strategy.
# 2. ``stop`` - Attempts to stop the containers with a 30 second timeout and then forcefully remove the current containers mounting the volume, without prompting
# 3. ``delete`` - Mounts the volume and deletes all of the files. May not work when a container is running a database, or the volumes modified by the entrypoint, i.e. adding user permissions.
# 4. ``error`` - Errors out instead of cleaning the volume
#
# The action for a specific volume is specified by setting the label ``com.vsi.just.clean_action``.
#
# For example, in a ``docker-compose.yaml`` file:
#
# .. code-block:: yaml
#
#   volumes:
#     venv:
#       labels:
#         com.vsi.just.clean_action: ask
#
# delete
# ------
#
# In the case of ``delete`` strategy, an optional labels ``com.vsi.just.clean_setup`` can be specified to designate what just target to run to repopulate a volume. Typically this just target should run ``sh -c ":"`` or similar. This allows the entrypoint or another command to properply setup the volume, and set permissions, etc...
#
#**
function docker_defaultify()
{
  arg=$1
  shift 1
  case $arg in
    build_recipes) # Build recipes
      JUST_DOCKER_COMPOSE_DIR="${VSI_COMMON_DIR}/docker/recipes" \
          COMPOSE_FILE="${VSI_COMMON_DIR}/docker/recipes/docker-compose.yml" \
          Docker-compose build ${@+"${@}"}
      extra_args=$#
      ;;
    build_recipes-auto) # Build recipes used in specified dockerfiles. "-" for \
                        # stdin; multiple files (via wildcards) accepted
      if [ "$#" = "0" ]; then
        source "${VSI_COMMON_DIR}/linux/colors.bsh"
        echo "${RED}ERROR:${NC} You must pass at least one argument to build recipes-auto" >&2
        return 1
      fi

      source "${VSI_COMMON_DIR}/linux/elements.bsh"

      # Set up cache (global) array of recipes already built, so we don't build
      # the same recipe multiple times.
      if ! is_array JUST_DOCKER_RECIPES; then
        JUST_DOCKER_RECIPES=()
      fi

      local recipes=($(get_docker_recipes ${@+"${@}"}))

      local tmp=()
      subtract_array recipes JUST_DOCKER_RECIPES tmp
      recipes=(${tmp+"${tmp[@]}"})

      JUST_DOCKER_RECIPES=(${JUST_DOCKER_RECIPES+"${JUST_DOCKER_RECIPES[@]}"} ${recipes+"${recipes[@]}"})

      if [ "${#recipes[@]}" != "0" ]; then
        justify build recipes "${recipes[@]}"
      fi
      extra_args=$#
      ;;
    docker_clean) # Delete a docker volume. The next container to use this \
                  # volume will automatically copy any content from the image.
      local volume_inspect_rv=0
      # local foo="$(bar)" || rv=$? does not work as one line in bash 4.2 or older. Ues two lines
      local volume_inspect
      volume_inspect="$(docker volume inspect "${1}")" 2>/dev/null || volume_inspect_rv=$?

      if [ "${volume_inspect_rv}" = "0" ]; then
        local rm_rv
        local rm_out
        local rm_err

        {
            IFS= read -r -d '' rm_err
            IFS= read -r -d '' rm_rv
            IFS= read -r -d '' rm_out
        } < <((printf '\0%s\0' "$(Docker volume rm "${1}"; printf '\0%d' "${?}" 1>&2)" 1>&2) 2>&1)
        # Command outputs stdout on 1, stderr on 2; then add "NUL+Return" Value on Stderr
        # printf will buffer stdout (letting "stderr+NUL+rv" stream out in real time)
        # printf then redirects its output to 2, so now 2 contains "stderr+NUL+rv+NUL+stdout"
        # finally, stderr is redirected to 1, allowing the read commands to read "stderr+NUL+rv+NUL+stdout"

        # Echo stdout as if the command was run normally. Important for dryrun
        echo "${rm_out}"

        if [ "${rm_rv}" != "0" ]; then
          local pattern='volume is in use - \[(.*)\]'
          [[ ${rm_err} =~ ${pattern} ]]
          local OLD_IFS="${IFS}"
          IFS=", "
          local containers=(${BASH_REMATCH[1]})
          IFS="${OLD_IFS}"

          pattern='"com\.vsi\.just\.clean_action": "([^"]+)"'
          local action
          if [[ ${volume_inspect} =~ $pattern ]]; then
            action="${BASH_REMATCH[1]}"
          else
            action=ask
          fi

          _docker_clean_actions "${1}" "${action}"
        fi
      else
        echo "${1} already removed" >&2
      fi

      extra_args=1
      ;;
    docker-compose_clean) # Delete a docker-compose volume. The next container \
                          # to use this volume will automatically copy any \
                          # content from the image. Use --all to clean all \
                          # volumes listed in the docker-compose.yml file
      if [ "${1}" = "--all" ]; then
        local DOCKER_INTERNAL_VOLUMES
        local volume
        docker-compose-list-internal-volumes < <(Just-docker-compose config)
        for volume in ${DOCKER_INTERNAL_VOLUMES[@]+"${DOCKER_INTERNAL_VOLUMES[@]}"}; do
          justify docker_clean "${COMPOSE_PROJECT_NAME}_${volume}"
        done
      else
        justify docker_clean "${COMPOSE_PROJECT_NAME}_${1}"
      fi
      extra_args=1
      ;;
    docker-compose_enter) # Enter a running container, running an interactive
                          # bash session. Set COMPOSE_SERVICES to limit to a
                          # specific service. Additional arguments are run in
                          # lieu of bash
      # not Docker-compose; no quotes
      local containers=($(docker-compose ps -q ${COMPOSE_SERVICES-} || :))
      if [ "${#containers[@]}" == 0 ]; then
        echo "No running containers found"
        extra_args=$#
        return 0
      elif [ "${#containers[@]}" == 1 ]; then
        local picked=1
      else
        local picked
        local pretty=()
        for picked in "${!containers[@]}"; do
          pretty[${picked}]="$(docker container inspect -f \
              '{{index .Config.Labels "com.docker.compose.service"}} - {{.Name}} ({{.Config.Hostname}})' \
              ${containers[$picked]}) $(docker ps --format {{.Status}} -f id=${containers[$picked]})"
        done
        picker "${pretty[@]}" || picked=$?
      fi

      # Give the dev a way to override the -it flags, should they ever need to
      local DOCKER_EXTRA_EXEC_ARGS=("${DOCKER_EXTRA_EXEC_ARGS[@]--it}")

      if [ "$#" = "0" ]; then
        Docker exec "${containers[$((picked-1))]}" bash
      else
        Docker exec "${containers[$((picked-1))]}" ${@+"${@}"}
      fi
      extra_args=$#
      ;;
    docker-compose_log) # Show logs from all service containers. Optionally \
         # specify service names to only log specific containers. Bug: Does \
         # not pick up containers that didn't exist when starting just log

      # Override the log target in your Justfile and call __docker-compose-log
      # if you need to set other parameters
      justify __docker-compose-log ${@+"${@}"}
      extra_args=$#
      ;;
    __docker-compose-log)
      function stop_logging(){ JUST_STOP_LOGGING=1; }
      JUST_STOP_LOGGING=0
      trap stop_logging INT
      trap stop_logging TERM
      while [ "${JUST_STOP_LOGGING}" == "0" ]; do
        Docker-compose logs --tail=20 -f ${@+"${@}"} || echo $?
        while [ "${JUST_STOP_LOGGING}" == "0" ] && ! docker_service_running | grep running > /dev/null; do
          sleep 1
        done
      done
      trap - INT
      trap - TERM
      extra_args=$#
      ;;

    docker) # Run generic docker command
      Docker ${@+"${@}"}
      extra_args=$#
      ;;

    docker-compose) # Run generic docker-compose command
      Just-docker-compose ${@+"${@}"}
      extra_args=$#
      ;;

    docker-compose_tag-all-stages) # Build and tag all stages of an image. $1 - compose filename, $2 - docker-compose service to build (for final stage)
      docker-compose_tag_all_stages "${1}" "${2}"
      extra_args=2
      ;;

    docker-compose_restore-from-cache) # Build all stages of an image from a pulled cache. $1 - compose filename, $2 - docker-compose service to build (for final stage), [$3...] - additional service names that might point to other stage targets in the same dockerfile.
      docker-compose_restore_from_cache "${@}"
      extra_args=$#
      ;;

    *)
      plugin_not_found=1
      ;;
  esac
  return 0
}

# :Arguments: ``$1`` - Volume to be removed
#             ``$2`` - Action to take
# :Parameters: ``containers`` - Array of containers using volume
#              ``volume_inspect`` - String of the result from ``docker volume inspect ${1}``
function _docker_clean_actions()
{
  case "${2}" in
    ask)
      echo "The following containers are using ${1}:"
      echo "${containers[*]}"

      local action
      picker "Stop and forcefully remove these containers then try again" \
             "Deletes all of the volumes files and repopulate" \
             "Do nothing and error" > /dev/null || action=$?

      if [ "${action}" = "1" ]; then
        _docker_clean_actions "${1}" stop
      elif  [ "${action}" = "2" ]; then
        _docker_clean_actions "${1}" delete
      elif  [ "${action}" = "3" ]; then
        _docker_clean_actions "${1}" error
      else
        _docker_clean_actions "${1}" unknown
      fi
      ;;
    delete)
      # Remove the files
      Docker run --rm --mount "type=volume,src=${1},dst=/data" alpine sh -c "find /data -maxdepth 1 -mindepth 1 -print0 | xargs -0 rm -rf"

      # If there is a com.vsi.just.clean_setup label
      pattern=$'"com\.vsi\.just\.clean_setup": "([^\n]*)"\n'
      if [[ ${volume_inspect} =~ $pattern ]]; then
        # Parse \" to "
        setup_cmd="${BASH_REMATCH[1]//\\\"/\"}"
        # Evaluate this string into arguments. By definition this is arbitrary
        # code execution, so eval is acceptable.
        eval "setup_cmd=(${setup_cmd})"
        # Run the just target
        justify "${setup_cmd[@]}"
      else
        echo "No 'com.vsi.just.clean_setup' label found for volume ${1}" >&2
        # false
      fi
      ;;
    stop)
      for x in "${containers[@]}"; do
        Docker stop -t 30 "${x}"
        Docker rm -f "${x}" || :
      done
      Docker volume rm "${1}"
      ;;
    error)
      false
      ;;
    *)
      echo "Unknown action ${2}"
      false
      ;;
  esac
}

# Idea from Issue #103
function set_docker_compose_project_name()
{
  if [ "${COMPOSE_PROJECT_NAME:+set}" != "set" ]; then
    local cwd_var="${JUST_PROJECT_PREFIX}_CWD"
    local user_var="${JUST_PROJECT_PREFIX}_USERNAME"
    if [ "${!user_var:+set}" = "set" ]; then
      COMPOSE_PROJECT_NAME=$(docker_compose_sanitize_project_name "${!cwd_var}" "${!user_var}")
    else
      COMPOSE_PROJECT_NAME=$(docker_compose_sanitize_project_name "${!cwd_var}")
    fi
  fi
}
