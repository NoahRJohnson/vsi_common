#!/usr/bin/env false

if [[ $- != *i* ]]; then
  source_once &> /dev/null && return 0
fi

#*# linux/string_tools

#**
# ============
# String Tools
# ============
#
# .. default-domain:: bash
#
# .. file:: string_tools.bsh
#
#**


# https://stackoverflow.com/a/3352015/4166604

#**
# .. function:: ltrim
#
# :Arguments: * ``$1`` - String to trim
#             * [``$2``] - Characters to trim. Default: [``:space:``]
# :Output: *stdout* - The trimmed string
#
# Left trim a string
#
# .. seealso::
#   :func:`trim` Trim from both ends in one call
#**
function ltrim()
{
  echo "${1#"${1%%[!${2-[:space:]}]*}"}"
}

#**
# .. function:: rtrim
#
# :Arguments: * ``$1`` - String to trim
#             * [``$2``] - Characters to trim. Default: [``:space:``]
# :Output: *stdout* - The trimmed string
#
# Right trim a string
#
# .. seealso::
#   :func:`trim` Trim from both ends in one call
#**
function rtrim()
{
  echo "${1%"${1##*[!${2-[:space:]}]}"}"
}

#**
# .. function:: trim
#
# :Arguments: * ``$1`` - String to trim
#             * [``$2``] - Characters to trim. Default: [``:space:``]. Can be another character or character classes, such as: alnum alpha ascii blank cntrl digit graph lower print punct space upper word xdigit. For multiple characters/classes, use standard pattern matching syntax, minus the []
# :Output: *stdout* - The trimmed string
#
# Trim a string
#
# .. rubric:: Example
#
# .. code-block:: bash
#
#   trim ' abcAcba ' # Trim the spaces
#   Result: 'abcAbca'
#
#   trim 'abcAcba' a # Trims the letter a off
#   Result: 'bcAcb'
#
#   trim 'abcAcba' [:lower:] # Trims lowercase letters
#   Result: 'A'
#
#   trim 'abcdAdcba' a-c # Trims range a-c
#   Result: 'dAd'
#
#   trim 'aebcAcbea' aeiou # Trims vowels
#   Result: 'bcAcb'
#
#   See Bash man on "Pattern Matching" for more possibilities. $2 is essentially
#   placed inside a set of []
#
# .. seealso::
#   :func:`ltrim` Trim only from the left
#   :func:`rtrim` Trim only from the right
#**
function trim()
{
  local x
  x="${1#"${1%%[!${2-[:space:]}]*}"}"
  echo "${x%"${x##*[!${2-[:space:]}]}"}"
}


#**
# .. function:: quote_escape
#
# :Arguments: * ``$1`` - String to escape
# :Output: *stdout* - The string with ' escaped properly
#
# Properly escape string for bash, adds ' for you, does not need extra quotes added to string. Useful for printing out instructions that are meant to be copy and pasted, no matter what characters are in the string. Also useful for ``eval``
#
# ``printf '%q' "$foo"`` does not always work exactly as intended with ``eval`` on bash 3.2. Either the ``\`` is not expanded when double quotes are uses, or ``~`` is expanded without double quotes. With this function, no bash expansion ever occurs.
#
# Quotes do not need to be added to any expression, as ``'`` are added for you.
#
# .. rubric:: Example
#
# .. code-block:: bash
#
#   eval "x=$(quote_escape "Hi \"  'ya \"")" # <-- Never add quotes after the =
#   [ "${x}" = "Hi \"  'ya \"" ]
#
# .. seealso::
#   :func:`quote_substitute_escape` for use in ``${x-something}``
#**
function quote_escape()
{
  # Gets around Bash <= 4.2 issue
  # https://unix.stackexchange.com/a/411047/123413
  local foo42=\'\\\'\'
  echo "'${1//\'/${foo42}}'"
  # All other bash substitutions do not occur in '
}

#**
# .. function:: quote_unescape
#
# :Arguments: * ``$1`` - Sring to unescape
# :Output: *stdout* - Unescaped string
#
# Unquote a string quoted using bashes rules for quotes, without using eval.
#
# The ``trap -p`` command outputs string using the single quote notation and only escapes ``'``, while ``declare -p`` used the double quote notation and only has to escape ``\`$"``. Only these escape charaters are supported, all other escapes will be left in.
#
# .. warning::
#
#     This only works for specific single quoted strings, like that outputted from :func:`quote_escape`. Mixing a string with ``"`` or ``$'`` will result in error. The only concatination of two strings supported is ``'\''``.
#**
function quote_unescape()
{
  local x
  if [ "${#1}" -ge 2 ]; then
    if [ "${1:0:1}" = "'"  -a "${1: -1}" = "'" ]; then
      x="${1:1:${#1}-2}" # Remove surrounding quotes
      # Gets around Bash <= 4.2 issue
      # https://unix.stackexchange.com/a/411047/123413
      local foo42="'"
      echo "${x//\'\\\'\'/${foo42}}"
      return
    elif [ "${1:0:1}" = '"'  -a "${1: -1}" = '"' ]; then
      x="${1:1:${#1}-2}" # Remove surrounding quotes
      x="${x//\\\$/\$}"
      x="${x//\\\`/\`}"
      x="${x//\\\"/\"}"
      echo "${x//\\\\/\\}"
      # printf '%b\n' "${x}" # supports //, but I think it's wrong to do \t \n, etc...
      return
    fi
  fi
  echo "${1}"
}

#**
# .. function:: quote_substitute_escape
#
# :Arguments: * ``$1`` - String to escape
# :Output: *stdout* - The string escaped properly
#
# Similar to :func:`quote_escape`, but can be used in the same use cases as :func:`quote_escape` and for variable substitution, e.g. the ``bar`` in ``${foo-bar}``.
#
# Unlike :func:`quote_escape`, quotes do need to be added to any expression. This is because quotes can be added outside the evaluation point of :func:`quote_substitute_escape`.
#
# .. rubric:: Example
#
# .. code-block:: bash
#
#   unset y
#   eval "x=\"${y-$(quote_substitute_escape "Hi \"  'ya \"")}\"" # <-- Need the \"
#   # Always add the \" after the =
#   [ "${x}" = 'Hi "  '\''ya "' ]
#
#   #also
#
#   eval "x=\"$(quote_substitute_escape "Hi \"  'ya \"")\"" # <-- Need the \"
#   [ "${x}" = 'Hi "  '\''ya "' ]
#
# .. seealso::
#   :func:`quote_escape` for the more generic case not in ``${}``
#**
function quote_substitute_escape()
{
  local x="${1//\\/\\\\}" # First excape \ to \\
  x="${x//\"/\\\"}"       # Then escape "
  x="${x//\$/\\\$}"       # Now start disabling Bash substitutions. $
  echo "${x//\`/\\\`}"    # And the last bash substitution, `
  # All other bash substitutions do not occur in "
}

#**
# .. function:: regex_escape
#
# :Arguments: * ``$1`` - String to escape
# :Output: *stdout* - The escaped string
#
# Adds '\' to the string, so it can be used as a literal string in a regex expression, assuming / is the search command separator
#
# .. var:: regex_escape_threshold
#
# The length threshold between using the pure bash version and sed version to. Set to 600 on Windows, else 50
#
# .. rubric:: Example
#
# .. code-block:: bash
#
#   $ regex_escape '***TEST***'
#   \*\*\*TEST\*\*\*
#
# .. Note::
#   An extra newline always shows up at the end, just like `echo` (without `-n`) would.
#   Only works for Basic Regex Expressions (BRE). A different function/flag would be needed for extended, as the rules are incompatible with each other (for example ``()``)
#**
if [ "${OS-}" = "Windows_NT" ]; then
  regex_escape_threshold=600
else
  regex_escape_threshold=50
fi

# https://unix.stackexchange.com/a/33005/123413
# Normal regex escapes $.*[\^,   (){}+?| must NOT be escaped
# Extended must escape (), and who know whatelse

function regex_escape()
{
  local out=''
  local -i i=0
  local str="${1}"
  if [ "${#str}" -gt "${regex_escape_threshold}" ]; then
    # Faster after sed is started
    sed '# Read all lines into one buffer
         :combine
         $bdone
         N
         bcombine
         :done
         s/[[$.*\^/]/\\&/g' <<< "${str}"
  else
    # Slower, but no process to load, so faster for short strings. On windows
    # this can be a big deal
    # local regex='[[$.*\^/]'
    while (( i < ${#str} )); do
      if [[ ${str:$i:1} =~ [[$.*\\/^] ]]; then
        out+="\\${str:$i:1}"
      else
        out+="${str:$i:1}"
      fi
      i+=1
    done
    echo "$out"
  fi
}

#**
# .. function:: regex_escape_range
#
# :Arguments: * ``$1`` - String to escape
# :Output: *stdout* - The escaped string range, including []
#
# Adds '\' to the string, so it can be used as a literal string in a regex expression as a character range. Basically this handles the special cases for ``^``, ``-``, and ``]``
#
# .. rubric:: Example
#
# .. code-block:: bash
#
#   $ regex_escape_range '^hk]'
#   []hk^]
#**
function regex_escape_range()
{
  local str="${1}"

  # Special case of ^ by itself, [^] will not work
  if [ "${str}" = "^" ]; then
    echo -n "^"
    return 0
  fi

  # ^ must not be fisrt
  if [[ ${str} =~ \^ ]]; then
    str="${str//^/}^"
  fi
  # - must be last
  if [[ ${str} =~ - ]]; then
    str="${str//-/}-"
  fi
  # ] must be first
  if [[ ${str} =~ ] ]]; then
    str="]${str//]/}"
  fi
  echo -n "[${str}]"
}

#**
# .. function:: uppercase
#
# :Arguments: * ``$1`` - String to convert
# :Output: *stdout* - String in uppercase
#
# Converts a string to uppercase, using ``bash`` or ``tr``
#**
if [ ${BASH_VERSINFO[0]} -ge 4 ]; then
  function uppercase()
  {
    echo "${1^^}"
  }
else
  function uppercase()
  {
    tr '[a-z]' '[A-Z]' <<< "${1}"
  }
fi

#**
# .. function:: lowercase
#
# :Arguments: * ``$1`` - String to convert
# :Output: *stdout* - String in lowercase
#
# Converts a string to lowercase, using ``bash`` or ``tr``
#**
if [ ${BASH_VERSINFO[0]} -ge 4 ]; then
  function lowercase()
  {
    echo "${1,,}"
  }
else
  function lowercase()
  {
    tr '[A-Z]' '[a-z]' <<< "${1}"
  }
fi

#**
# .. function:: null_dump
#
# :Arguments: ``$1`` - Header string
#             ``$2`` - Name of array to be dumped
#             [``$3``...] - Repeat ``$1`` and ``$2``
# :Output: *stdout* - Null separated dump of data
#
# Prints out multiple arrays, null separated.
#
# Prints out the header, than two nulls, then each element of the array, separated by single nulls. Then a double null between the last element, and the next header, and repeat.
#
# .. rubrice:: Examples
#
# .. code::
#
#    foo\0\0
#    foo\0\0\0\0bar\0\0
#    foo\0\0boo\0shoe\0toe\0\0bar\0car\sar
#
# .. rubric:: Parsing scheme
#
# #. Split by ``\0\0``. Now you have a list going (header, data, header, data, ...)
# #. Split data by ``\0`` and you have the array elements again.
#
# .. note::
#
#    Skips empty fields. If this is not done, then two nulls would end up next to each othere in the data section, breaking parking. If you need to preserve empty data, then another scheme should be used, either use a "None" value or similar, or another function
#**
function null_dump()
{
  # This isn't neccessary
  # local _null_dump_first_line=1

  while (( $# )); do
    if [ "$#" -gt 2 ]; then
      _null_dump "$1" "$2"
    else
      _null_dump "$1" "$2" 1
    fi
    shift 2
  done
}

#**
# .. function:: _null_dump
#
# :Inputs: ``$1`` - Header string
#          ``$2`` - Array name
#          [``$3``] - Last(1), default 0. Set to 1 if this is the last group
# :Output: *stdout* - Null separated dump of one group of data
#          ``_null_dump_first_line`` - Used to track if this is the first group or not, automatically set and unset for you, no need to set yourself.
#
# Internal function. Prints one group. Must be combined with all the calls to get the proper number of nulls between groups. (The two nulls between groups are split among calls to :func:`_null_dump`
#
# *Can* be called manually.
#**
function _null_dump()
{
  # Handle name collisions
  if [ "${2}" = "pattern" -o "${2}" = "indirect" -o \
       "${2}" = "indirect_i" -o "${2}" = "at_least" -o \
       "${2}" = "_null_dump_first_line" -o "${2}" = "_null_dump_last_line" ]; then
    local array_copy="${2}[@]"
    array_copy=(${!array_copy+"${!array_copy}"})
    _null_dump "${1}" array_copy "${3-0}"|| return $?
    return 0
  fi

  local _pattern=""
  local indirect="${2}[@]"
  local indirect_i
  local at_least_1=0

  # If _null_dump_first_line is unset, then this must be the first
  : ${_null_dump_first_line=1}
  local _null_dump_last_line="${3-0}"

  # Create the pattern for writing the header

  # The first group does not start with a null, but subsequent groups need to
  # have a double null between them, this adds that second null
  if [ "${_null_dump_first_line}" = "0" ]; then
    _pattern="\0"
  fi
  # Add the first of the two nulls that separate the header and the data. The
  # second null is added either by the _pattern += below, or in the last line,
  # the null is written first to avoid a trailing null at the end.
  _pattern+="%s\0"
  # This has to use %s, or else if $1 is a numver, it will combine with the
  # previous \0 and be a bigger number

  # If not the last
  if [ "${_null_dump_last_line}" = "0" ]; then
    # Add the second null of the double null between the header and data
    _pattern+='\0'
    printf "${_pattern}" "${1}"

    # Now the data pattern is to write data and a null, to separate the data
    # elements. This null will also be the first of the two nulls between the
    # last data elemetns and the next header, since this is already know to be
    # not the last group.
    _pattern="%s\0"
  else
    printf "${_pattern}" "${1}"
    # Print null first, since this is the last group, we don't want a trailing
    # null. When printing the first element, the null becomes the second null
    # in the double null between the header and the first data element, else
    # it is the null between elements
    _pattern="\0%s"
  fi

  # Loop over the array
  for indirect_i in ${!indirect+"${!indirect}"}; do
    # Don't print empty elements, that would create a double null
    if [ "${indirect_i}" != "" ]; then
      printf "${_pattern}" "${indirect_i}"
      at_least_1=1
    fi
  done

  if [ "${at_least_1}" = "0" ]; then
    # If none were printed
    # When not the last line:
    #   We need to add an extra null to make 4 total (Two from the pattern, one
    #   here, and one added from the next pattern that is not the first line)
    # When the last line:
    #   We need to add an extra null to make 2 total (One from the pattern that
    #   was not the last line, and this one)
    # Either way, we need the extra null when no elements were printed
    printf '\0'
  fi

  # If last line
  if [ "${_null_dump_last_line}" = "1" ]; then
    # unset the first line variable. This helps when calling _null_dump manually
    # So you don't have to unset this yourself, or in case you forget to make
    # it local
    unset _null_dump_first_line
  else
    # Else, mark the next line will not be the first line, so the logic works.
    _null_dump_first_line=0
  fi
}
