#!/usr/bin/env false bash

if [[ $- != *i* ]]; then
  source_once &> /dev/null && return 0
fi

#*# linux/compat.bsh

#**
# =======================
# Compatibility Variables
# =======================
#
# .. default-domain:: bash
#
# .. file:: compat.bsh
#
# A collection of variables to help cope with the differences between different operating systems and versions.
#**

#**
# .. function:: load_vsi_compat
#
# Typically, this does not need to be called directly. :func:`load_vsi_compat` is run automatically when :file:`compat.bsh` is sourced. However, if you need to reload the variables, e.g. :envvar:`VSI_SED_COMPAT` is set and you want to get the forced compatibility flags, then you could call :func:`load_vsi_compat`, but this would be extremely rare.
#**
function load_vsi_compat()
{
  #**
  # Sed flags
  # =========
  #
  # While most flags between GNU and BSD (macos) sed are fairly compatible, a few create issues in corner cases.
  #
  # .. envvar:: VSI_SED_COMPAT
  #
  #   Force ``bsd`` or ``gnu`` mode when loading the ``sed`` flags
  #**

  if [ -z "${VSI_SED_COMPAT-}" ]; then
    local VSI_SED_COMPAT
    if [[ ${OSTYPE-} = darwin* ]]; then
      VSI_SED_COMPAT=bsd
    elif [ "${OS-}" = "Windows_NT" ] || [[ $(sed --version) = *GNU* ]]; then
      VSI_SED_COMPAT=gnu
    else
      VSI_SED_COMPAT=bsd
    fi
  fi

  #**
  # .. variable:: sed_flag_rE
  #
  # Flag to enable extended regex support in sed. The GNU flag is ``-r``, while the BSD flag is ``-E``. macos does not support ``-r`` and GNU sed prior to 4.2 does not accept ``-E``. Using this variable should always yield the correct flag.
  #
  # .. rubric:: Example
  #
  # .. code-block:: bash
  #
  #   sed -${sed_flag_rE} 's|foo(.*)|bar\1.|'
  #   # Notice no quotes above
  #**
  # Needed for CentOS 6 running sed 4.1.5
  if [ "${VSI_SED_COMPAT-}" = "gnu" ]; then
    sed_flag_rE='r'
  else
    sed_flag_rE='E'
  fi

  #**
  # .. variable:: sed_flag_i
  #
  # When using inplace replacement on sed, the macos version requires an argument to the ``-i`` flag, the extension added to the output file. The GNU version does not support this. Using this flag will perform an inplace replacement with no added extension. The :var:`sed_flag_i must come last when combined with other flags (see example below).
  #
  # .. rubric:: Example
  #
  # .. code-block:: bash
  #
  #   sed -${sed_flag_i} 's|foo|bar|' some_file.txt
  #   # You cannot put quotes around sed_flag_i, or else it will not work on macos
  #
  #   # Not ok
  #   sed -${sed_flag_i}n ...
  #   # This is ok
  #   sed -n${sed_flag_i} ...
  #   # Also ok
  #   sed -${sed_flag_i} -n ...
  #**

  # Handle macos BSD version
  if [[ ${OSTYPE-} = darwin* ]]; then
    sed_flag_i="i ''"
  else
    sed_flag_i='i'
  fi

  #**
  # Date
  # ====
  #
  # The following variables will help cope with the difference in the ``date`` command, as seamlessly as possible.
  #
  # .. variable:: date_feature_nanoseconds
  #
  # Non-GNU versions of ``date`` do not support the nanosecond sequence for a date format (e.g. BSD and busybox).
  #
  # :Value: * ``0`` - Supports nanosecond precision ``%N``
  #         * ``1`` - Does not support nanoseconds
  #**
  if [ "${OS-}" = "Windows_NT" ] || [[ $(date +%N) =~ ^[0-9]+$ ]]; then
    date_feature_nanoseconds=0
  else
    date_feature_nanoseconds=1
  fi

  #**
  # Bash
  # ====
  #
  # The following variables will help cope with the difference in bash versions, as seamlessly as possible.
  #
  # .. variable:: bash_declare_array_quote
  #
  # In bash version 4.3 and older, ``declare -p`` of an array adds an extra ``'`` around the array. This variable stores the state of that variable
  #
  # :Value: * **(null)** - Bash 4.4 or newer
  #         * ``'`` - Bash 4.3 or older
  #
  # .. variable:: bash_feature_parameter_transformation
  #
  # Does bash support Parameter Transformations, e.g. ``${var@a}``
  #
  # :Value: * ``0`` - Bash does support parameter transformations (Bash 4.4 or newer)
  #         * ``1`` - Bash does not support parameter transformations
  #**
  if [ "${BASH_VERSINFO[0]}${BASH_VERSINFO[1]}" -ge "44" ]; then
    bash_declare_array_quote=""
    bash_feature_parameter_transformation=0
  else
    bash_declare_array_quote="'"
    bash_feature_parameter_transformation=1
  fi

  #**
  # .. variable:: bash_feature_declare_name_reffing
  #
  # Do bash variables support name reffing
  #
  # :Value: * ``0`` - Bash does support name reffing (Bash 4.3 or newer)
  #         * ``1`` - Bash does not support name reffing
  #
  # .. variable:: bash_feature_declare_print_function
  #
  # Does ``declare`` support printing a function via ``declare -pf function_name``. Work around include: ``declare -F`` to list all functions and ``type function_name``, however the first line needs to be removed.
  #
  # :Value: * ``0`` - ``declare`` supports printing a function
  #         * ``1`` - ``declare`` does not support printing a specific function.
  #
  # .. variable:: bash_bug_local_shadow_exported_variable
  #
  # In bash 4.2 and older, a local variable can shadow an exported variable, obscuring it from children processes. This is a confusing behavior that has to occasionally be corrected.
  #
  # :Value: * ``0`` - Local variables shadow exported variable in children processes
  #         * ``1`` - Local variables do not shadow exported variable
  #
  # .. rubric:: Example
  #
  # .. code-block:: bash
  #
  #    export x=12
  #    function foo()
  #    {
  #      local x
  #      declare -p x        # in the x=11 case, this is 11?!
  #      # export x          # Doesn't make a difference. x is already exported
  #      compgen -A export x # compgen always sees x, shadowed or not.
  #      bash -c "declare -p x"
  #    }
  #    foo
  #    # x will be undefined when bash_bug_local_shadow_exported_variable is 0
  #    # x will be 12 when bash_bug_local_shadow_exported_variable is 1
  #    export -f foo; x=11 bash -c foo # Same result as above
  #    x=13 foo # x is always 13 and in the bash child too. No explanation for this behavior
  #**
  if [ "${BASH_VERSINFO[0]}${BASH_VERSINFO[1]}" -ge "43" ]; then
    bash_feature_declare_name_reffing=0
    bash_feature_declare_print_function=0
    bash_bug_local_shadow_exported_variable=1
  else
    bash_feature_declare_name_reffing=1
    bash_feature_declare_print_function=1
    bash_bug_local_shadow_exported_variable=0
  fi

  #**
  # .. variable:: bash_feature_declare_global
  #
  # Does bash support declaring global variables with the ``declare`` command.
  #
  # :Value: * ``0`` - Bash supports ``declare -g``
  #         * ``1`` - Bash does not support ``declare -g``
  #**
  if [ "${BASH_VERSINFO[0]}${BASH_VERSINFO[1]}" -ge "42" ]; then
    bash_feature_declare_global=0
    bash_declared_unset_value='' # Documented below
  else
    bash_feature_declare_global=1
    bash_declared_unset_value='=""' # Documented below
  fi

  #**
  # .. variable:: bash_feature_printf_array_assignment
  #
  # Does ``printf -v`` support storing to array variables
  #
  # :Value: * ``0`` - ``printf`` does support storing to arrays (Bash 4.1 or newer)
  #         * ``1`` - ``printf`` only supports storing to non-array variables
  #
  # .. variable:: bash_feature_allocate_file_descriptor
  #
  # Does ``exec {varname}>&1`` work.
  #
  # :Value: * ``0`` - ``exec`` can auto allocate an unused file descriptor
  #         * ``1`` - File descriptors must be manually allocated.
  #
  # .. seealso::
  #   :func:`file_tools.bash find_open_fd`
  #**
  if [ "${BASH_VERSINFO[0]}${BASH_VERSINFO[1]}" -ge "41" ]; then
    bash_feature_printf_array_assignment=0
    bash_feature_allocate_file_descriptor=0
  else
    bash_feature_printf_array_assignment=1
    bash_feature_allocate_file_descriptor=1
  fi

  #**
  # .. variable:: bash_feature_associative_array
  #
  # Does bash have associative arrays
  #
  # :Value: * ``0`` Bash does have associative arrays (4.0 or newer)
  #         * ``1`` Bash does not have associative arrays (3.2)
  #**
  if [ "${BASH_VERSINFO[0]}" -ge "4" ]; then
    bash_feature_associative_array=0
  else
    bash_feature_associative_array=1
  fi

  #**
  # .. variable:: bash_regex_special_characters_non_literal
  #
  # Most instances of bash require special characters to be literal in regular expressions (e.g. ``$'\n'``). However, on operating systems such as alpine, a special character will be matched based in its non-literal form (e.g. ``"\n"``). This has nothing to do with the version of bash, but rather how it was compiled (regex might come from g++'s implementation).
  #
  # :var:`bash_regex_special_characters_non_literal` will be set if the non-literal form works. Currently, the literal form always appears to work.
  #
  # :Value: * ``0`` - Non literal form works (e.g. ``"\t")
  #         * ``1`` - Non literal form does not work
  #**
  local x=$'foo\nbar'
  local re='\n'
  if [[ ${x} =~ ${re} ]]; then
    bash_regex_special_characters_non_literal=0
  else
    bash_regex_special_characters_non_literal=1
  fi

  #**
  # .. variable:: bash_bug_declare_fails_local_declared_unset_variable
  #
  # Bash 4.3 has a bug where ``declare -p var`` fails if a local variable is declared, but has no set value. The workaround is to find the variable in ``declare -p``
  #
  # :Value: * ``0`` - Has declare fails bug
  #         * ``1`` - Does not have the declare fails bug
  #
  # .. variable:: bash_bug_declare_fails_global_declared_unset_variable
  #
  # Bash 4.0 to 4.3 has a bug where ``declare -p var`` fails if a global variable is declared, but has no set value. The workaround is to find the variable in ``declare -p``
  #
  # :Value: * ``0`` - Has declare fails bug
  #         * ``1`` - Does not have the declare fails bug
  #
  # .. variable:: bash_declared_unset_value
  #
  # Bash 3.2 through 4.1 has a confusion behavior where unset declared variables appear to be set to null ``""`` instead of unset, in the output of ``declare -p``. However these versions of bash do indeed have an "unset by declared state", it just can't be queried using the output of ``declare -p``.
  #
  # :Value: * ``=""`` - The characters seen after ``declare varname``
  #         * **(null)**
  #
  # .. rubric:: Example
  #
  # .. code-block:: bash
  #
  #    declare x
  #    if declare -p x &> /dev/null; then
  #      assert_str_eq "$(declare -p x)" "declare -p x${bash_declared_unset_value}"
  #    fi
  #
  #    # How to detect if variable is unset but declared
  #**

  local y
  if declare -p y &> /dev/null; then
    bash_bug_declare_fails_local_declared_unset_variable=1
  else
    bash_bug_declare_fails_local_declared_unset_variable=0
  fi

  if declare -p bash_bug_declare_fails_global_declared_unset_variable &> /dev/null; then
    bash_bug_declare_fails_global_declared_unset_variable=1
  else
    bash_bug_declare_fails_global_declared_unset_variable=0
  fi

  #**
  # .. variable:: bash_bug_substitute_empty_funcname
  #
  # ``FUNCNAME`` is the only builtin array in bash that is likely to be declared but unset (when stack depth is zero). In bash 4.3 and 4.4, there is a bug where an using parameter expansion on ``FUNCNAME`` when unset will incorrectly expand (e.g. ``${FUNCNAME[@]+example}``). This could be due to the fact that funcname isn't really empty in global scope, but just doesn't show up as populated until in its first function scope
  #
  # .. note::
  #
  #    Typing this into an interactive bash session will not show this bug. It has to be in a file that is sourced or run for this bug to show up.
  #**
  if [ "${BASH_VERSINFO[0]}${BASH_VERSINFO[1]}" = "43" ] || [ "${BASH_VERSINFO[0]}${BASH_VERSINFO[1]}" = "44" ]; then
    bash_bug_substitute_empty_funcname=0
  else
    bash_bug_substitute_empty_funcname=1
  fi

  #**
  # .. variable:: bash_bug_ifs_array_slice_expansion
  #
  # In some versions of bash (3.2 is the only known version), ``@`` expanding an array and slicing it when IFS is not space will fail to expand into multiple arguments.
  #
  # :Value: * ``0`` - Bug present
  #         * ``1`` - Not bugged
  #
  # .. rubric:: Example
  #
  # .. code-block:: bash
  #
  #   $ x=(11 22 33 44)
  #   $ IFS=x
  #   $ z=("${x[@]:2}")
  #   # @ expansion should be unaffected by IFS, unlike * expansion
  #   declare -a z='([0]="33 44")'       # Wrong
  #   declare -a z='([0]="33" [1]="44")' # Right
  #**
  local x=(11 22 33 44)
  local IFS=x
  local z=("${x[@]:2}")
  if [ "${z[0]}" = "33 44" ]; then
    bash_bug_ifs_array_slice_expansion=0
  else
    bash_bug_ifs_array_slice_expansion=1
  fi
}

# Can't do this sanity check on bash 4.3 or 4.4. Oh well
if [ "${BASH_VERSINFO[0]}${BASH_VERSINFO[1]}" != "43" ] && [ "${BASH_VERSINFO[0]}${BASH_VERSINFO[1]}" != "44" ]; then
  if [ "0"${FUNCNAME[@]+"${#FUNCNAME[@]}"} -ne 0 ]; then
    echo "bash_bug_declare_fails_global_declared_unset_variable will not be accurate unless ${BASH_SOURCE[0]} is sourced from global scope" >&2
  fi
fi

declare bash_bug_declare_fails_global_declared_unset_variable

# The purpose of this file is to set all these flag. Make it a function to help
# encapsulate in new_just
load_vsi_compat
