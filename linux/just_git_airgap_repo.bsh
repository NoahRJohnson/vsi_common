#!/usr/bin/env false bash

if [[ $- != *i* ]]; then
  source_once &> /dev/null && return 0
fi

JUST_DEFAULTIFY_FUNCTIONS+=(relocate_git_defaultify)
JUST_HELP_FILES+=("${BASH_SOURCE[0]}")

#*# just/plugins/just_git_airgap_repo

#**
# .. default-domain:: bash
#
# ===============================================
# J.U.S.T. Git Mirror to an Air-gapped Repository
# ===============================================
#
# .. file:: just_git_airgap_repo.bsh
#
# While creating a git mirror is as simple as ``git clone --mirror``, unfortunately this git command does not support git submodules or lfs. These functions help in creating and subsequently cloning a mirror of a project with submodules and/or git lfs.
#
# .. rubric:: Example
#
# Example usage:
#
# 1. ``just git export-repo https://github.com/visionsystemsinc/vsi_common.git master ~/`` - Mirror the repository and recursively create mirrors of all submodules currently in the master branch.
# 2. Transfer ``vsi_common_prep/transfer_{date}.tgz`` to your destination.
# 3. Initialize bare repositories on the git server for vsi_common and its submodule, recipes. Note: vsi_common_prep/repo_map.env contains the list of the submodules in a project and their expected server paths.
#   - https://git-server.com/org/vsi_common.git
#   - https://git-server.com/org/recipes.git
# 4. Extract the archive
#   a) In vsi_common_prep, edit mirror.env and set
#     - MIRROR_GIT_SERVER_URL=https://git-server.com/
# REVIEW i assume we should use a common organization and not each submodule's external organization
#     - MIRROR_GIT_REPO_ORG=org
# ALTERNATIVELY the Justfile could ask for these things
# 5. ``source setup.env``
# 6. ``just git import-repo`` - Push the mirrored repository and all submodules to a new git server as defined by info.env
#
# A developer can then run:
# 1. ``git clone https://gitserver.com/visionsystemsinc/vsi_common.git`` 
# 2. ``just git clone-airgap-repo`` - Clone submodules recursively from the new mirror
#**

source "${VSI_COMMON_DIR}/linux/ask_question"
source "${VSI_COMMON_DIR}/linux/git_mirror"

#**
# .. envvar:: GIT
#
# Name/path of git executable
#
# Instead of hard-coding "git" everywhere, use the variable :envvar:`GIT` so that when the need comes, it is easier to switch which executable gets called. Set to empty string to have any calls to git skipped.
#
# All :func:`relocate_git_defaultify` targets will be skipped if the value of :envvar:`GIT` is not found or empty.
#
# .. note::
#   When using the GIT env variable in this file, do not surround it with quotes as you normally would. Although this prevents using a path to ``git`` with a space in it, in exchange, it may be possible (eventually) to enable a dry-run-ish capability if GIT is set to 'echo git'.
#**

: ${GIT=git}


# unit tests:
# NOTE a tracking branch must actually be setup
# nothing unpushed - branch (non-tracking) behind origin/master
# nothing unpushed - branch (non-tracking) equal to origin/master
# unpushed commits - branch (non-tracking) ahead of origin/master
# no outgoing commits - tracking_branch is behind its tracked origin/tracking_branch
# no outgoing commits - tracking_branch is behind its tracked origin/master
# no outgoing commits - tracking_branch is equal to its tracked origin/tracking_branch
# outgoing commits - tracking_branch is ahead of its tracked origin/tracking_branch
# outgoing commits - tracking_branch is ahead of its tracked origin/master
# ignore outgoing commits - remote-tracking branch removed, but the local-tracking branch remains
# ignore outgoing commits - no tracking branches


#**
# .. function:: unpushed_commits
#
# List all unpushed commits to stdout
#
# List all commits on branches that have not been pushed to a remote. This is a set operation: it lists all the commits from a branch in the DAG except those reachable by a remote-tracking branch. It does not require an *associated* remote-tracking branch
#
# REVIEW what order should these go in
# :Arguments: - ``1`` - A remote-tracking branch's name to filter by; e.g., master. If unset, then don't filter
#             - ``2`` - A name of a remote to filter by; e.g., origin. If unset, then don't filter
#
# :Output: - ``*stdout*`` - Print all unpushed commits for tracking branches to stdout
#**

function unpushed_commits()
{
  # Note: Only supports passing in a single branch and remote name
  local branch="${1---branches}"
  local remote_name="${2-}"

  local commits="$(${GIT} log "${branch}" --not --remotes="${remote_name}" --decorate --graph --format=short --color=always)"
  echo "${commits}"
}

#**
# .. function:: git_tracking_branches
#
# Find remote- and corresponding local-tracking branches
#
# :Arguments: - ``1`` - A name of a remote to filter by; e.g., origin. If unset, then don't filter
#
# :Output: - just_git_tracking_branches - An array of local-tracking branch names
#          - just_git_remote_tracking_branches - A corresponding array of remote-tracking branch names
#
# .. note::
#    - A branch that you create locally and then push to a remote is not configured as a remote-tracking branch by default. You must use the -u flag with 'git push' or 'git branch'.
#   - A branch cannot track multiple remotes.
#   - Requires git >= 1.9.0
#**

function git_tracking_branches()
{
  # REVIEW could support multiple remote names with a for loop
  local remote_name="${1-}"

  local OLD_IFS="${IFS}"
  IFS=$'\n'
  # E.g., upstream:short=origin/master, refname=refs/heads/master and
  # upstreeam:track=[gone] if the remote-tracking branch has been pruned
  # Note: %(upstream:track) requires git >= 1.9.0
  # Note: No quotes around subshell to create array
  local tracking_branches=($( \
      ${GIT} for-each-ref --format='%(upstream:short) %(refname) %(upstream:track)' refs/heads | \
      # Discard lines in which upstream is unset, i.e., those with a leading
      # space; also trim whitespace at the end of each line
      grep -v '^ ' | grep -v '\[gone\]$' | grep "^${remote_name}" | sed 's/[[:space:]]+$//' || :))
  IFS="${OLD_IFS}"
  #
  # Similarly: git rev-parse --abbrev-ref master@{upstream} will also give the
  # tracking branch (or error if one doesn't exist or has been pruned). This
  # can be combined with git for-each-ref --format='%(refname:short)' refs/heads
  # which lists all local branches.
  # Alternatively: git branch -vv provides the same tracking information as
  # upstream:track, even in git 1.8.3
  # RE this is the only command to get this info in git 1.8.3; although it can
  # be calculated manually with git log --format='%H' branch@{upstream}..branch
  # for outgoing commits and git log --format='%H' branch..branch@{upstream}
  # for incoming
  # git remote show origin actually queries the remote; however, it doesn't
  # provide the same level of tracking detail

  just_git_tracking_branches=()
  just_git_remote_tracking_branches=()
  # FIXME how to do this without the if statement; args in array have spaces.
  # Do you have to set the IFS again?
  if [ "${#tracking_branches}" -gt 0 ]; then
    local tracking_branch
    for tracking_branch in "${tracking_branches[@]}"; do
      local branch="$(echo "${tracking_branch}" | awk '{print $2}')"
      # Strip refs/heads prefix from the remoteref
      just_git_tracking_branches+=("${branch/refs\/heads\//}")
      just_git_remote_tracking_branches+=("$(echo "${tracking_branch}" | awk '{print $1}')")
    done
  fi
}

#**
# .. function:: outgoing_commits
#
# List all unpushed commits for a tracking branches to stdout
#
# REVIEW what order should these go in
# :Arguments: - ``1`` - A remote-tracking branch's name to filter by; e.g., master. If unset, then don't filter by branch name
#             - ``2`` - A name of a remote to filter by; e.g., origin. If unset, then don't filter
#
# :Output: - ``*stdout*`` - Print all unpushed commits for tracking branches to stdout
#
# .. note:: A branch cannot track multiple remotes.
#
# TODO i would like to support two optional arrays, but i think this would require ENV vars. is that acceptable
#**

function outgoing_commits()
{
  local remote_name="${2-}"

  local tracking_branches
  if [ $# -eq 0 ]; then
    git_tracking_branches "${remote_name}" # Sets just_git_tracking_branches
    tracking_branches=("${just_git_tracking_branches[@]}")
  else
    tracking_branches=("${1}")
  fi

  # This will list only the outgoing commits for a local-tracking branch
  local tracking_branch
  local commits=()
  for tracking_branch in "${tracking_branches[@]}"; do
    commits+=("$(${GIT} log --decorate --graph --format=short --color=always "${tracking_branch}"@{upstream}.."${tracking_branch}")")
  done
  local OLD_IFS="${IFS}"
  IFS=$'\n'
  echo "${commits[*]}"
  IFS="${OLD_IFS}"
}

#**
# .. function:: submodule_summary
#
# Compare the expected commit of each submodule to its current working tree
#
# Using ``git diff --submodule=log``, compare the working tree of each submodule to the version commited to HEAD of the super project, and list any commits that are missing or now present in the submodule. For example, if an earlier commit in the submodule is checked out, there will be missing commits in the submodule according to the super project. Similarly, if a commit is made to the submodule, there will be new commits present in the submodule according to the super project.
#
# :Output: - ``*stdout*`` - Each submodule's differences in terms of commits
#
# .. seealso:: https://git-scm.com/docs/git-diff#Documentation/git-diff.txt---submoduleltformatgt
#
# TODO support iterating through all submodules
#**

function submodule_summary()
{
  local OLD_IFS="${IFS}"
  IFS=$'\n'
  for x in $("${GIT}" config --name-only --file .gitmodules --get-regexp '^submodule\..*\.path$'); do
    "${GIT}" diff --submodule=log "$("${GIT}" config --file .gitmodules --get "${x}")"
  done
  IFS="${OLD_IFS}"
}

# TODO it would be nice to have a function to check for unpushed commits in a submodule for its commited state
# RE there is a 'git push --recurse-submodules=check' flag (available in git 1.8.0)

#**
# .. function:: parse_url
#
# Parse a URL
#
# Parse a URL into its various parts: scheme, authority, user, host, port, rpath, query, fragment. Parsing URLs 100% correctly is HARD. This is not that solution.
#
# :Arguments: ``$1`` - URL
#
# .. rubric:: Example
#
# .. code-block:: bash
#
# parse_url https://visionsystemsinc.github.io:443/vsi_common/just/quickstart_user.html?highlight=J.U.S.T#what-is-j-u-s-t
#
# :Output:
#   ``just_url_parsed_scheme`` - e.g., https
#   ``just_url_parsed_authority`` - e.g., visionsystemsinc.github.io:443
#   ``just_url_parsed_host`` - e.g., visionsystemsinc.github.io
#   ``just_url_parsed_port`` - e.g., 443
#   ``just_url_parsed_rpath`` - e.g., vsi_common/just/quickstart_user.html
#   ``just_url_parsed_query`` - e.g., highlight=J.U.S.T
#   ``just_url_parsed_fragment`` - e.g., #what-is-j-u-s-t
#
# .. note::
#    From https://stackoverflow.com/a/45977232
#
# TODO move to a parse_url.bsh script
#**

function parse_url()
{
  # Following regex is based on https://tools.ietf.org/html/rfc3986#appendix-B
  # with additional sub-expressions to split authority into userinfo, host and
  # port
  local URI_REGEX='^(([^:/?#]+):)?(//((([^:/?#]+)@)?([^:/?#]+)(:([0-9]+))?))?(/([^?#]*))(\?([^#]*))?(#(.*))?'
  #                  ||            |  |||            |         | |            | |        |  |        | |
  #                  |2 scheme     |  ||6 userinfo   7 host    | 9 port       | 11 rpath |  13 query | 15 fragment
  #                  1 scheme:     |  |5 userinfo@             8 :...         10 path    12 ?...     14 #...
  #                                |  4 authority
  #                                3 //...

  # Note: No quotes around URI_REGEX
  if [[ "${1}" =~ ${URI_REGEX} ]]; then
    just_url_parsed_scheme="${BASH_REMATCH[2]}"
    just_url_parsed_authority="${BASH_REMATCH[4]}"
    #just_url_parsed_user="${BASH_REMATCH[6]}"
    just_url_parsed_host="${BASH_REMATCH[7]}"
    just_url_parsed_port="${BASH_REMATCH[9]}"
    just_url_parsed_rpath="${BASH_REMATCH[11]}"
    just_url_parsed_query="${BASH_REMATCH[13]}"
    just_url_parsed_fragment="${BASH_REMATCH[15]}"
    return 0
  fi
  return 1 # URL did not parse
}

#**
# .. function:: make_remote_urls_pushable
#
# Change the remote url of a git repo to use the git@ prefix instead of https
#
# Query the git repository's remotes; if the URL of the remote is specified using the the https:// protocol, convert it to the ssh transfer protocol (git@..) to make pushing changes to the remote server easier. Assume a very basic url format: https://gitserver.com/co/project.git without port, query, or fragment sections. Warn if these exist
#
# :Arguments: - ``1`` - A name of a remote to filter by; e.g., origin. If unset, then don't filter
#**

function make_remote_urls_pushable()
{
  local specified_remote_name="${1-}"

  local remote
  ${GIT} remote -v | grep '(push)$' | while read remote;
  do
    local remote_name
    local remote_url
    read -r remote_name remote_url <<< "$(echo "${remote}" | awk '{print $1 " " $2}')"
    # REVIEW is this the best way to check if specified_remote_name is set
    if [ "${specified_remote_name}" != "" ] && [ "${specified_remote_name}" != "${remote_name}" ]; then
      continue
    fi

    # Note: If the git server has a non-standard port (which would not be the
    # same as https port), you have to do ssh://git@server:port/...
    if parse_url "${remote_url}"; then # Sets just_url_parsed_host and just_url_parsed_rpath
      if [ "${just_url_parsed_port}" != "" ] || \
         [ "${just_url_parsed_query}" != "" ] || \
         [ "${just_url_parsed_fragment}" != "" ]; then
        echo "WARNING URL is non-standard. Skipped"
      elif [ "${just_url_parsed_scheme}" == "http" ] || \
           [ "${just_url_parsed_scheme}" == "https" ]; then
        remote_git_url="git@${just_url_parsed_host}:${just_url_parsed_rpath}"
        ${GIT} remote set-url "${remote_name}" --push "${remote_git_url}"
      fi
    fi
  done
}

#**
# .. function:: relocate_git_defaultify
#
# Git relocate plugin for just
#**

function relocate_git_defaultify()
{
  arg=$1
  shift 1
  case $arg in
    git_export-repo) # Export a mirror of the git repository, including all \
                     # submodules, to a tarball
      url="${1-"$(${GIT} config --get remote.origin.url)"}"
      branch="${2-master}"
      # TODO add support for output directory
      git_mirror_main "${url}" "${branch}"
      # REVIEW is this how to handle extra args in this case
      if [ "$#" -gt 0 ]; then
        extra_args=1
      fi
      ;;

    git_import-repo) # Push a repo exported with `git export-repo` to an \
                     # initialized git repo
      git_push_main ${@+"${@}"}
      extra_args=$#
      ;;

    git_clone-airgap-repo) # Clone a repo exported with `git export-repo`. This \
                           # is necessary because we do not want to update the \
                           # url's of the submodules
      git_clone_main ${@+"${@}"}
      extra_args=$#
      ;;

    # TODO Support iterating through all submodules too. This could be useful
    # to make sure all submodules have been pushed to their associated
    # remote/branch
    # TODO Generalize to support outgoing_commits too
    git_unpushed-commits) # List unpushed commits on a branch
      if ! command -v ${GIT} >& /dev/null; then
        echo "Git not found, skipping listing of unpushed commits" >&2
        return 0
      fi

      local commits="$(unpushed_commits)"
      if [ "${commits}" != "" ]; then
        local ncommits="$(echo "${commits}" | grep -o '^\* commit' | wc -l | tr -d '[:space:]')"
        if [ "${ncommits}" -eq 0 ]; then
          : # pass
        elif [ "${ncommits}" -eq 1 ]; then
          echo "There is ${ncommits} unpushed commit:"
          echo
        elif [ "${ncommits}" -gt 1 ]; then
          echo "There are ${ncommits} unpushed commits:"
          echo
        fi
        echo "${commits}"
      fi
      if [ "$#" -gt 0 ]; then
        extra_args=1
      fi
      ;;

    git_make-remote-urls-pushable) # Change the remote url of all submodules to \
                                   # use the git@ prefix instead of https
      if ! command -v ${GIT} >& /dev/null; then
        echo "Git not found, skipping remote url conversion" >&2
        return 0
      fi

      # TODO support iterating through all submodules
      make_remote_urls_pushable
      ;;

    *)
      plugin_not_found=1
      ;;
  esac
  return 0
}