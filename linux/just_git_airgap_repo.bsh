#!/usr/bin/env false bash

if [[ $- != *i* ]]; then
  source_once &> /dev/null && return 0
fi

if [ -z ${VSI_COMMON_DIR+set} ]; then
  VSI_COMMON_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.."; pwd)"
fi

source "${VSI_COMMON_DIR}/linux/ask_question"
source "${VSI_COMMON_DIR}/linux/git_mirror"
source "${VSI_COMMON_DIR}/linux/uwecho.bsh"
source "${VSI_COMMON_DIR}/linux/parser.bsh"
source "${VSI_COMMON_DIR}/linux/requirements.bsh"
source "${VSI_COMMON_DIR}/linux/dir_tools.bsh"
source "${VSI_COMMON_DIR}/linux/findin"

#*# just/plugins/just_git_airgap_repo

JUST_DEFAULTIFY_FUNCTIONS+=(relocate_git_defaultify)
JUST_HELP_FILES+=("${BASH_SOURCE[0]}")

#**
# .. default-domain:: bash
#
# ===============================================
# J.U.S.T. Git Mirror to an Air-gapped Repository
# ===============================================
#
# .. file:: just_git_airgap_repo.bsh
#
# While creating a git mirror is as simple as ``git clone --mirror``, unfortunately this git command does not support git submodules or lfs. These functions help in creating and subsequently cloning a mirror of a project with submodules and/or git lfs.
#
# .. rubric:: Example
#
# Mirror a repository and push it to a new air-gaped git server:
#
# 1. ``just git export-repo https://github.com/visionsystemsinc/vsi_common.git master ~/vsi_common_prep`` - Mirror the repository and recursively create mirrors of all submodules currently in the master branch.
# 2. Transfer ``vsi_common_prep/transfer_{date}.tgz`` to your destination.
# 3. On the destination, create a directory, e.g., vsi_common_prep, and move the archive into it
# 4. Extract the archive (the archive will extract directly into this directory)
#
#   a) In vsi_common_prep, edit repo_map.env and set the JUST_GIT_AIRGAP_MIRROR_URL environment variable. For example,
#
#     - JUST_GIT_AIRGAP_MIRROR_URL=https://git-server.com/projectA
#
# 5. If not already, initialize bare repositories on the air-gapped git server for vsi_common and its submodule, recipes. In this example, these should be located at
#
#   - https://git-server.com/projectA/vsi_common.git
#   - https://git-server.com/projectA/recipes.git
#
# 6. ``source setup.env``
# 7. ``just git import-repo`` - Push the mirrored repository and all submodules to a new git server as defined by repo_map.env
# 8. Incremental updates can be pushed to the repositories using much the same process. See :file:`git_mirror_main`.
#
# A developer can then run:
# 1. ``git clone https://git-server.com/projectA/vsi_common.git``
# 2. ``just git clone-airgap-repo`` - Clone submodules recursively from the new mirror
#
# Note however, that a project that uses vsi_common as a submodule must add support in the setup.env file to initialize and update the vsi_common submodule before this target can be called (see :func:`print_git_airgap_submodule_update`).
#
# .. seealso::
#
#   :file:`git_mirror`: :func:`git_mirror_main`, :func:`git_push_main`, and :func:`git_clone_main`
#**

#**
# .. envvar:: GIT
#
# Name/path of git executable
#
# Instead of hard-coding "git" everywhere, use the variable :envvar:`GIT` so that when the need comes, it is easier to switch which executable gets called. Set to empty string to have any calls to git skipped.
#
# All :func:`relocate_git_defaultify` targets will be skipped if the value of :envvar:`GIT` is not found or empty.
#
# .. note::
#
#   When using the GIT env variable in this file, do not surround it with quotes as you normally would. Although this prevents using a path to ``git`` with a space in it, in exchange, it may be possible (eventually) to enable a dry-run-ish capability if GIT is set to ``echo git``.
#**

: ${GIT=git}

#**
# .. function:: log_unpushed_commits
#
# List all unpushed commits to stdout
#
# List all commits on branches that have not been pushed to a remote. This is a set operation: it lists all the commits from a branch in the DAG except those reachable by a remote-tracking branch. It does not require an *associated* remote-tracking branch
#
# :Arguments: - [``$1``] - A name of a remote to filter by; e.g., origin. If unset, then don't filter
#             - [``$2``] - A branch's name to filter by; e.g., master. If unset, then don't filter
#
# :Output: - ``*stdout*`` - Print all unpushed commits for tracking branches to stdout
#**

function log_unpushed_commits()
{
  # NOTE Only supports passing in a single branch and named remote
  local remote_name="${1-}"
  local branch="${2---branches}"

  local commits="$(${GIT} log --decorate --graph --format=short --color=always \
      "${branch}" --not --remotes="${remote_name}")"

  _log_commits_helper "unpushed" "${commits}"
}

function _log_commits_helper()
{
  local label="${1}"
  local commits="${2}"

  if [ "${commits}" != "" ]; then
    local ncommits="$(echo "${commits}" | grep -o '^\*' | wc -l | tr -d '[:space:]')"
    if [ "${ncommits}" -eq 0 ]; then
      : # pass
    elif [ "${ncommits}" -eq 1 ]; then
      echo "There is ${ncommits} "${label}" commit:"
      echo
    elif [ "${ncommits}" -gt 1 ]; then
      echo "There are ${ncommits} "${label}" commits:"
      echo
    fi
    echo "${commits}"
  fi
}

#**
# .. function:: get_tracking_branches
#
# Find remote- and corresponding local-tracking branches
#
# :Arguments: - [``$1``] - A name of a remote to filter by; e.g., origin. If unset, then don't filter
#             - [``$2``] - A branch's name to filter by; e.g., master. If unset, then don't filter by branch name
#
# :Output: - ``just_git_tracking_branches`` - An array of local-tracking branch names
#          - ``just_git_remote_tracking_branches`` - A corresponding array of remote-tracking branch names
#          - [``*stdout*``] - If ``$2`` is specified, print the respective remote-tracking branch, or the empty string if there is no tracking branch
#
# .. note::
#
#   - A branch that you create locally and then push to a remote is not configured as a local-tracking branch by default. You must use the -u flag with ``git push`` or ``git branch``.
#   - A branch cannot track multiple remotes.
#**

function get_tracking_branches()
{
  # REVIEW Could support multiple named remotes with a for loop
  local remote_name="${1-}"

  local branches
  if [ $# -lt 2 ]; then
    local OLD_IFS="${IFS}"
    IFS=$'\n'
    branches=($(${GIT} for-each-ref --format='%(refname:short)' refs/heads))
    IFS="${OLD_IFS}"
  else
    branches=("${2}")
  fi

  just_git_tracking_branches=()
  just_git_remote_tracking_branches=()
  local branch
  for branch in ${branches+"${branches[@]}"}; do
    local remote_branch_rv=0
    local remote_branch
    # git rev-parse will error if the branch doesn't exist or has been pruned;
    # although unfortunately, it is same error code in both cases. The stderr
    # could be parsed to differentiate...
    remote_branch="$(${GIT} rev-parse --abbrev-ref "${branch}"@{upstream} 2> /dev/null)" || remote_branch_rv=$?
    if [ "${remote_branch_rv}" -ne 0 ]; then
      continue
    fi
    if [ -n "${remote_name}" ] && [[ "${remote_branch}" != "${remote_name}/"* ]]; then
      continue
    fi
    just_git_tracking_branches+=("${branch}")
    just_git_remote_tracking_branches+=("${remote_branch}")
  done
  # If a branch was specified, then echo its respective tracking branch
  if [ $# -eq 2 ]; then
    # Empty string if no tracking branch
    echo "${just_git_remote_tracking_branches[0]-}"
  fi
  #
  # Alternatively,
  #   git for-each-ref --format='%(upstream:short) %(refname) %(upstream:track)' refs/heads
  # where, for example, upstream:short=origin/master, refname=refs/heads/master
  # and upstream:track=[ahead 3] or [gone] if the remote-tracking branch has
  # been pruned. upstream:short is a blank space (' ') if upstream is unset,
  # i.e., there is no remote-tracking branch setup
  # NOTE %(upstream:track) requires git >= 1.9.0
  #
  # Alternatively: git branch -vv provides the same tracking information as
  # upstream:track, even in git 1.8.3
  # RE this is the only command to get this info in git 1.8.3; although it can
  # be calculated manually with git log --format='%H' branch..branch@{upstream}
  # for incoming commits and git log --format='%H' branch@{upstream}..branch
  # for outgoing (see log_outgoing_commits)
  # RE git rev-list --left-right --boundary branch@{upstream}...branch lists
  # both incoming and outgoing changes as well (the symmetric difference)
  # RE This is not strictly relevant to what I'm doing here though
  #
  # git remote show origin actually queries the remote; however, it doesn't
  # provide the same level of tracking detail
  #
  # Finally,
  #   remote="$(git config --get branch."${branch}".remote)" and
  #   tracking="$(git config --get branch."${branch}".merge | cut -d'/' -f3-)"
  # can be combined to provide the local-tracking branch, and then
  #   git show-ref refs/remotes/"${remote}/${tracking}"
  # can be used to see if the remote-tracking branch has been pruned
  # RE git show-rev will error if the branch doesn't exist or has been pruned;
  # although unfortunately, it is same error code in both cases
}

#**
# .. function:: log_outgoing_commits
#
# List all unpushed commits for tracking branches to stdout
#
# :Arguments: - [``$1``] - A name of a remote to filter by; e.g., origin. If unset, then don't filter
#             - [``$2``] - A local-tracking branch's name to filter by; e.g., master. If unset, then don't filter by branch name
#
# :Output: - ``*stdout*`` - Print all unpushed commits for tracking branches to stdout
#
# .. note::
#
#   A branch cannot track multiple remotes.
#**

function log_outgoing_commits()
{
  # NOTE Only supports passing in a single branch and named remote
  local remote_name="${1-}"

  local tracking_branches
  if [ $# -lt 2 ]; then
    local just_git_tracking_branches
    local just_git_remote_tracking_branches
    get_tracking_branches "${remote_name}" # Sets just_git_[remote_]tracking_branches
    tracking_branches=(${just_git_tracking_branches+"${just_git_tracking_branches[@]}"})
  else
    tracking_branches=("${2}")
  fi

  # This will list only the outgoing commits for a local-tracking branch
  local tracking_branch
  local commits=()
  for tracking_branch in ${tracking_branches+"${tracking_branches[@]}"}; do
    commits+=("$(${GIT} log --decorate --graph --format=short --color=always \
        "${tracking_branch}"@{upstream}.."${tracking_branch}")")
  done
  local OLD_IFS="${IFS}"
  IFS=$'\n'
  commits=${commits+"${commits[*]}"}
  IFS="${OLD_IFS}"

  _log_commits_helper "outgoing" "${commits}"
}

#**
# .. function:: make_remote_url_pushable
#
# Change the remote url of a git repo to use the git@ syntax instead of https
#
# In a git repository (or submodule), if the (last) URL of the remote is specified using the the https:// protocol, convert it to the ssh transfer protocol (git@..) to make pushing changes to the remote server easier. Assume a very basic url format: https://git-server.com/co/project.git without port, query, or fragment sections. Warn if these exist. Do nothing if a pushurl is already configured
#
# :Arguments: - [``$1``] - The name of a remote to convert. Default: origin
#
# .. note::
#
#   This does not change a submodule's tracked URL (i.e., the URL in the .gitmodules file) nor a submodule's URL (i.e., .git/config:submodule), only the URL of the remote in .git/\*\*/config (e.g., .git/modules/docker/recipes/config:remote)
#**

function make_remote_url_pushable()
{
  local remote_name="${1-origin}"

  # Don't do anything if a pushurl is already configured
  if ${GIT} config --get remote."${remote_name}".pushurl &> /dev/null; then
    echo "Skipping: pushurl already configured"
    return
  fi

  local remote_url="$(${GIT} config --get remote."${remote_name}".url)"

  local remote_git_url_rv=0
  local remote_git_url
  # local foo="$(bar)" || rv=$? does not work as one line in bash 4.2 or older. Ues two lines
  remote_git_url="$(_https_to_git_protocol "${remote_url}")" || remote_git_url_rv=$?
  if [ "${remote_git_url_rv}" == "0" ]; then
    # NOTE since git 1.8, a remote (e.g., origin) can have multiple associated
    # pushurls (see .git/config)
    # RE providing the old url (remote_url) will update the correct url
    #${GIT} remote set-url "${remote_name}" --push "${remote_git_url}" "${remote_url}"
    # RE If a pushurl is configured, this function returns early; therefore,
    # assume a pushurl is not configured
    ${GIT} remote set-url "${remote_name}" --push "${remote_git_url}"
  else # See if URL is already in the expected format
    # This is very simple; basically undo the simple transform done here.
    # Perhaps one day we will have a git remote url parser in parser.bsh
    local remote_https_url="$(echo "${remote_url}" | sed -e 's#^git@#https://#' -e 's#:#/#3')"
    if ! parse_url "${remote_https_url}"; then
      echo "WARNING URL is non-standard. Skipping ${remote_url}"
    fi
  fi
}

function _https_to_git_protocol()
{
  local remote_url="${1}"

  # Be very conservative about which URLs will convert
  # NOTE If the git server has a non-standard port (which would not be the
  # same as https port), you have to do ssh://git@server:port/...
  local just_url_parsed_scheme
  local just_url_parsed_authority
  local just_url_parsed_host
  local just_url_parsed_port
  local just_url_parsed_rpath
  local just_url_parsed_query
  local just_url_parsed_fragment
  if parse_url "${remote_url}"; then # Sets just_url_parsed_host, just_url_parsed_rpath, etc.
    if [ "${just_url_parsed_port}" != "" ] || \
       [ "${just_url_parsed_query}" != "" ] || \
       [ "${just_url_parsed_fragment}" != "" ]; then
      echo "${remote_url}"
      return 1
    elif [ "${just_url_parsed_scheme}" == "http" ] || \
         [ "${just_url_parsed_scheme}" == "https" ]; then
      local remote_git_url="git@${just_url_parsed_host}:${just_url_parsed_rpath}"
      echo "${remote_git_url}"
    fi
  else
    echo "${remote_url}"
    return 1
  fi
}

#**
# .. function:: submodule_summary
#
# Bash port of ``git rev-parse --show-superproject-working-tree``
#
# This is a bash port of ``git rev-parse --show-superproject-working-tree`` (available in git
# 2.13.7 and later), which show the absolute path of the root of the superproject’s working tree.
#
# .. note::
#
#   This won't work if the git-dir is separate. No idea how to detect that
#**

function toplevel()
{
  dir="$(${GIT} rev-parse --git-dir | awk -F '/.git' '{print $1}')"
  if [ "${dir}" = ".git" ]; then
    echo "${PWD}"
  else
    echo "${dir}"
  fi
}

#**
# .. function:: submodule_summary
#
# Compare the expected commit of each submodule to its current working tree
#
# Using ``git diff --submodule=log``, compare the working tree of each submodule to the version committed to HEAD of the super project, and list any commits that are missing and/or now present in the submodule. For example, if an earlier commit in the submodule is checked out, there will be missing commits in the submodule according to the super project. Similarly, if a commit is made to the submodule, there will be new commits present in the submodule according to the super project. Of course, the commit graph could diverge in more complicated ways.
#
# :Output: - ``*stdout*`` - Each submodule's differences in terms of commits
#
# .. seealso::
#
#   https://git-scm.com/docs/git-diff#Documentation/git-diff.txt---submoduleltformatgt
#**

# TODO Support iterating through all submodules
function submodule_summary()
{
  local OLD_IFS="${IFS}"
  IFS=$'\n'
  for x in $(${GIT} config --name-only --file .gitmodules --get-regexp '^submodule\..*\.path$'); do
    ${GIT} diff --submodule=log "$(${GIT} config --file .gitmodules --get "${x}")"
  done
  IFS="${OLD_IFS}"
}

#**
# .. function:: get_submodule_paths_recursively
#
# Get the displaypath to each submodule
#
# Get what git refers to as the displaypath of the submodule: the relative path from the current working directory to the root of the containing repository and then to each submodule. This path is defined by the git-specified environment variable displaypath (or prefix depending on git version).
#
# :Output: *stdout* - The displaypath to each submodule (recursively); e.g., docker/recipes
#
# .. note::
#
#   Alternatively, the path (aka sm_path) for the submodule can be queried with ``git config`` (although, by itself, not recursively):
#
#     ``git config submodule.docker/recipes.path``
#
#   which looks up the (sm\_)path using the submodule's name (which here is the same as the sm_path...although that does not have to be the case) in the parent repository's git config file (if set), and
#
#     ``git config -f .gitmodules submodule.docker/recipes.path``
#
#   which reads what is in the parent repository's .gitmodules file.
#
# If path is set, ``git submodule sync`` will synchronize these two configurations using the primary source-of-truth, the .gitmodules file, and the default remote of the current branch, if set; otherwise origin. :func:`git_sync_submodules_recursively` will do the same but using the specified remote name.
#
# Admittedly, by themselves, these commands not very useful. :func:`git_mirror get_submodule_names` uses ``git config --name-only --get-regexp '^submodule\..*\.url$' | sed 's|.url$||'`` to first query the submodule names and then lookup their paths.
#
# .. note::
#
#   The submodules must have been checked out recursively (which is obviously not the case in a bare/mirror repo)
#
# .. seealso::
#
#   :func:`just_git_functions submodule-helper-list` and :func:`git_mirror get_submodule_names`; although these are not recursive, they both are used to recurse manually through all the submodules
#**

function get_submodule_paths_recursively()
{
  local OLD_IFS="${IFS}"
  IFS=$'\n'
  local submodule_path
  # At some point, prefix was deprecated and removed in favor of displaypath
  # NOTE prefix/displaypath only provides the expected path if this command is
  # run from the root of the top-level repository. Fortunately, that is the case
  # in the Justfile.
  # Alternatively, add JUST_PROJECT_DIR to just or use :func:`toplevel`
  #
  # displaypath is built-up from sm_path by ``git submodule foreach`` as it
  # iterates through the submodules using ``git submodule--helper list``, which
  # queries info from .git/index; see
  # https://github.com/git/git/blob/v2.16.0/git-submodule.sh#L304
  # Similarly, passing 'echo "${toplevel}/${sm_path}"' as the sh command to
  # git submodule foreach will print the absolute path of all the submodules
  for submodule_path in $(${GIT} submodule foreach --quiet --recursive 'echo "${prefix-"${displaypath}"}"'); do
    # Remove trailing slashes because on some versions of git (1.8.3, 2.17.1),
    # prefix has a trailing slash
    echo "${submodule_path%/}"
  done
  IFS="${OLD_IFS}"
}

#**
# .. function:: get_submodule_urls_recursively
#
# Get all submodule URLs
#
# Get the (last) URL for each submodule (recursively) from its .git/\*\*/config file (e.g., .git/modules/docker/recipes/config) for the specified remote (origin by default). Note: Since git 1.8, a remote can have multiple associated URLs (and pushurls) (see .git/config).
#
# :Arguments: [``$1``] - The name of a remote. Note: this same remote must exist in all submodules. Default: origin
# :Output: *stdout* - The URL of each submodule (recursively); e.g., https://github.com/VisionSystemsInc/docker_recipes.git
#
# .. note::
#
#   Alternatively, the URL for the submodule can be queried with ``git config`` (although, by itself, not recursively):
#
#     ``git config submodule.docker/recipes.url``
#
#   which looks up the URL in the parent repository's git config file, and
#
#     ``git config -f .gitmodules submodule.docker/recipes.url``
#
#   which reads what is in the parent repository's .gitmodules file. ``git submodule sync`` will synchronize these two configurations using the primary source-of-truth, the .gitmodules file, and the default remote of the current branch, if set; otherwise origin. :func:`git_sync_submodules_recursively` will do the same but using the specified remote name.
#
# .. note::
#
#   The submodules must have been checked out recursively (which is obviously not the case in a bare/mirror repo)
#**

function get_submodule_urls_recursively()
{
  local remote_name="${1-origin}"

  # REVIEW Should i unset GIT_DIR?
  ${GIT} submodule foreach --quiet --recursive \
      "export GIT; bash -euc 'echo \"\$(${GIT} config --get remote."${remote_name}".url)\"'"
}

#**
# .. function:: create_repo_map
#
# Create the contents of the repo_map.env file
#
# Create the repository mapping such that, once the JUST_GIT_AIRGAP_MIRROR_URL environment variable is defined, it can be sourced by :func:`git_push_main` and :func:`git_clone_main` in :file:`git_mirror`.
#
# :Argument: ``$1`` - The top-level repository name (e.g., vsi_common)
#
# :Parameters: [``ASSOCIATIVE_REPO_MAP``] - Set to a value to create the repo map as an associative-array, ``repos``, as opposed to two partitioned arrays (which is bash 3.2 compatible): ``repo_urls`` and ``repo_paths``. (Default: unset; i.e., partitioned)
#
# :Output: *stdout* - The contents of the repo_map.env file. For example,
#
# .. code-block:: bash
#
#   # The urls are specified with the env variable :envvar:`JUST_GIT_AIRGAP_MIRROR_URL`,
#   # which must be set to the mirrored repositories' new location on the
#   # air-gapped git server. Delay setting this variable until the archive has
#   # been moved to the destination in case the information must be controlled
#   JUST_GIT_AIRGAP_MIRROR_URL=
#
#   repo_paths=(
#     ./
#     ./docker/recipes
#   )
#   repo_urls=(
#     "${JUST_GIT_AIRGAP_MIRROR_URL}/vsi_common.git"
#     "${JUST_GIT_AIRGAP_MIRROR_URL}/recipes.git"
#   )
#
#  If, for example, :envvar:`JUST_GIT_AIRGAP_MIRROR_URL` was set to
#  https://git-server/projectA, these urls would expand to:
#    https://git-server/projectA/vsi_common.git and
#    https://git-server/projectA/recipes.git
#
# .. note::
#
#   The user can override this function if it does not suit her needs
#**

function create_repo_map()
{
  local repo_name="${1}"

  local ASSOCIATIVE_REPO_MAP="${ASSOCIATIVE_REPO_MAP-}"

  local OLD_IFS="${IFS}"
  IFS=$'\n'
  # The (relative) path from the top-level repository to each submodule (recursively)
  # No quotes around subshell to create array (although IFS must be correct)
  local repo_paths=("${repo_name}" $(get_submodule_paths_recursively))
  IFS="${OLD_IFS}"

  local repo_path
  local repo_urls=()
  for repo_path in "${repo_paths[@]}"; do
    # The respective url for each submodule (recursively)
    # NOTE Quotes around JUST_GIT_AIRGAP_MIRROR_URL aren't necessary here because
    # the entries will be quoted when printed to file
    repo_urls+=('${JUST_GIT_AIRGAP_MIRROR_URL}'/$(basename "${repo_path}")'.git')
  done
  # Rename the top-level repo to '.'
  repo_paths[0]='.'

  uwecho '# NOTE: This file is automatically created by
          #   just:just_git_airgap_repo.bsh:create_repo_map
          #
          # If this mapping between submodules and URLs does not suit your
          # needs, you can edit this file directly before calling
          # `just git import-repo` or override `create_repo_map` before calling
          # `just git export-repo`

          '

  # JUST_GIT_AIRGAP_MIRROR_URL can use filesystem paths, but they need to be
  # absolute paths because git_mirror:git_push_main changes into the directory
  # of each repository it pushes
  uwecho '### YOU MUST SET THIS VARIABLE ###
          # For example:
          # JUST_GIT_AIRGAP_MIRROR_URL=git@git-server.com:projectA
          JUST_GIT_AIRGAP_MIRROR_URL=

          '

  # This is not as nice as if the script would die automatically when it is
  # sourced if an env variable is null, but that doesn't seem possible;
  # set -u only check for unset variables, not null
  # RE Although this does provide a nice error message
  uwecho '# Error if this env variable is unset
          : ${JUST_GIT_AIRGAP_MIRROR_URL:?"ERROR: Please set this variable in ./repo_map.env"}

          '

  # Serialize the repository mapping such that it can be sourced by
  # :func:`git_push_main` and :func:`git_clone_main` in :file:`git_mirror`.
  if [ -n "${ASSOCIATIVE_REPO_MAP}" ]; then
    printf 'declare -A repos\n'
    for index in "${!repo_paths[@]}"; do
      # The %s in [] is implicitly quoted by bash
      printf 'repos[%s]="%s"\n' "${repo_paths[$index]}" "${repo_urls[$index]}"
    done
  else
    printf 'repo_paths=(\n'
    printf '  "%s"\n' "${repo_paths[@]}"
    printf ')\n\n'
    printf 'repo_urls=(\n'
    printf '  "%s"\n' "${repo_urls[@]}"
    printf ')\n'
  fi
  printf '\n\n'

  print_git_airgap_submodule_update
}

#**
# .. function:: orphan_commit_repo_map
#
# Orphan commit the repo_map.env file
#
# Given a repository mapping like the one produced by :func:`create_repo_map`, make an orphan commit in the repository (on a branch named __just_git_mirror_info_file by default) to a file named repo_map.env. An intermediate product of this function is a shallow clone (which uses hardlinks by default) of the current repo to a directory called __just_git_clone, which is removed at the end of the function.
#
# :Arguments: - ``$1`` - The contents of the repo_map.env file; i.e., the file that maps between the submodule's path and its new URL
#             - [``$2``] - The name of the branch on which to make the orphan commit. Default: __just_git_mirror_info_file
#**

function orphan_commit_repo_map
{
  repo_map="${1}"
  orphan_branch="${2-__just_git_mirror_info_file}"

  # Clone (non-recursively) the repo in which to make the orphan commit.
  # Supports starting in a bare repo. Also avoids possibly needing to run
  # 'git reset --hard' after checking out the orphan branch followed by
  # 'git checkout' after committing to it.
  # NOTE Uses hard-links on linux
  #
  # TODO Clone into an automatically deleting temporary directory; requires
  # mktemp_compat from dir_tools.bsh
  # RE this temp dir does not auto-delete
  # NOTE Do not redirect stdout to /dev/null
  if [ -n "$(ls -A __just_git_clone 2>/dev/null || :)" ]; then
    echo "The temporary directory, ./__just_git_clone, already exists and is"
    echo "not empty. This script will delete it and continue."
    ask_question "Is that ok?" answer_delete n
    [ "$answer_delete" == "0" ] && return 1
    rm -rf __just_git_clone
  fi
  ${GIT} clone --no-checkout . __just_git_clone
  pushd __just_git_clone &>/dev/null
    # Avoids checking out the files in the previously checked-out branch
    # and staging them for deletion when switching to a new (orphan) branch,
    # which then requires running 'git reset --hard' and/or 'git rm -rf .'
    # REVIEW I can't find a better way to do this
    rm -f .git/refs/heads/*
    ${GIT} checkout "${orphan_branch}" 2>/dev/null || \
        ${GIT} checkout --orphan "${orphan_branch}"

    echo "${repo_map}" > repo_map.env

    ${GIT} add repo_map.env
    ${GIT} -c "user.name=just git_export-repo" \
           -c "user.email=<just@export-repo.git>" commit \
           --allow-empty \
           -m "the repo_map.env file needed by just:git_mirror that maps repo_paths to urls"
    ${GIT} push --force origin "${orphan_branch}"
  popd &>/dev/null
  rm -rf __just_git_clone
  #
  # ALTERNATIVELY
  #current_branch="$(git rev-parse --abbrev-ref HEAD)"
  #${GIT} checkout "${orphan_branch}" 2>/dev/null || \
  #     ${GIT} checkout --orphan "${orphan_branch}"
  #git reset --hard # This is important if "${orphan_branch}" was just created
  #
  #echo "${repo_map}" > repo_map.env
  #
  #${GIT} checkout "${current_branch}" # This could be expensive
}

#**
# .. function:: add_import-repo_just_project
#
# Create a simple just project in the prep_dir
#
# This function creates a simple just project (a README.md, setup.env, and Justfile that includes this plugin) in the air-gapped mirror cache (the prep_dir) created by the `git_export-repo` just target. This just project can be used to push (aka import) the mirrored repositories to their respective air-gapped git server by using the git_import-repo just target.
#
# :Arguments: ``$1`` - The output directory (prep_dir) that caches the mirrored repositories and archive to be transferred
#
# :Output: ``${1}/{README.md,setup.env,Justfile}``
#**

function add_import-repo_just_project()
{
  # Need the abs path because we change directories when copying vsi_common
  prep_dir="$(real_path "${1}")"

  # git archive external/vsi_common to ${prep_dir}/.vsi_common
  # does not include submodules, but that that's ok
  rm -rf "${prep_dir}"/.vsi_common
  pushd "${VSI_COMMON_DIR}" &>/dev/null
    ${GIT} archive --format=tar --prefix=.vsi_common/ HEAD | ( cd "${prep_dir}" && tar xf - )
  popd &>/dev/null

  uwecho 'These mirrored git repositories were automatically created by

            just:just_git_airgap_repo:git_export-repo

          To push them to their respective air-gapped git server, simply:

          1. Edit repo_map.env to set the required environment variable (or,
             if necessary, update repo_map.env as needed)
          2. `source setup.env`
          3. `just git import-repo`
          ' > "${prep_dir}"/README.md
  # REVIEW It might be nicer not to import a plugin here so that there is only
  # one target in just help
  # REVIEW Perhaps the just project in the prep_dir should be able to run
  # just git export-repo
  uwecho '#!/usr/bin/env bash
          export JUST_PROJECT_PREFIX=AIRGAP_MIRROR
          export JUST_VERSION="'"${JUST_VERSION}"'"
          if [ -z "${AIRGAP_MIRROR_CWD+set}" ]; then
            export AIRGAP_MIRROR_CWD="$(\cd "$(\dirname "${BASH_SOURCE[0]}")"; \pwd)"
          fi

          JUST_LOCAL_SETTINGS=/dev/null source "${VSI_COMMON_DIR}/linux/just_env" /dev/null

          source "${VSI_COMMON_DIR}/linux/just_git_airgap_repo.bsh"

          cd "${AIRGAP_MIRROR_CWD}"
          function caseify() { defaultify ${@+"${@}"}; }
          ' > "${prep_dir}"/Justfile
  uwecho 'export JUST_SETUP_SCRIPT="$(basename "${BASH_SOURCE[0]}")"
          source "$(dirname "${BASH_SOURCE[0]}")/.vsi_common/env.bsh"
          unset JUSTFILE
          ' > "${prep_dir}"/setup.env
}

#**
# .. function:: print_git_airgap_submodule_update
#
# Print a func to bootstrap ``just`` by cloning a relocated repository
#
# After (shallow) cloning the air-gapped repository, the submodules must be re-configured and initialized/updated (recursively). This is handled by the git_clone-airgap-repo just target. However, this is not possible without the vsi_common submodule, which must first be initialized and updated.
#
# This function prints a function, git_airgap_submodule_update, which is appended to repo_map.env and orphan committed in the git_import-repo just target. git_airgap_submodule_update follows the same steps as :func:`git_mirror:git_clone_main`.
#
# In order to call git_airgap_submodule_update, repo_map.env must be grabbed out of the orphan commit and then sourced. Obviously, no just functions can be called yet, so this must be done in the file specified by :envvar:`JUST_SETUP_SCRIPT` (typically called setup.env). For example, the setup.env script, which typically looks like:
#
# .. code-block:: bash
#
#   export JUST_SETUP_SCRIPT="$(basename "${BASH_SOURCE[0]}")"
#   source "$(dirname "${BASH_SOURCE[0]}")/external/vsi_common/env.bsh"
#
# would become:
#
# .. code-block:: bash
#
#   export JUST_SETUP_SCRIPT="$(basename "${BASH_SOURCE[0]}")"
#   if [ ! -f "$(dirname "${BASH_SOURCE[0]}")/external/vsi_common/env.bsh" ]; then
#     echo "'just' could not be loaded. Trying to setup the repository as an"
#     echo "air-gapped repository"
#     # source the contents of repo_map.env (in a bash 3.2 compatible way)
#     source /dev/stdin <<< \
#         "$(git show origin/__just_git_mirror_info_file:repo_map.env 2>/dev/null || :)"
#     if ! declare -Fx git_airgap_submodule_update; then
#       echo "ERROR the vsi_common submodule could not be found!"
#       return 1
#     fi
#     git_airgap_submodule_update external/vsi_common
#   fi
#   source "$(dirname "${BASH_SOURCE[0]}")/external/vsi_common/env.bsh"
#
# After the setup.env file has been sourced, it is possible to run ``just git clone-airgap-repos`` to recursively initialize and clone the submodules from their air-gapped mirrors
#
# TODO: This should be a git hook; however, the hook would still have to be added in the setup.env file
#**

function print_git_airgap_submodule_update()
{
  # NOTE Do not use vsi_common functionality in this function! It is saved to
  # repo_map.env and sourced in setup.env
  # REVIEW If I ever create it, replace with `declare -f update_submodule` from
  # git_mirror
  uwecho '#*
          # .. function:: git_airgap_submodule_update
          #
          # Reconfigure and update a submodule
          #
          # :Arguments: ``$1`` - A relative path (from the top-level repo) to a submodule
          # :Parameters: ``repo_paths`` - The (relative) path from the top-level repository
          #                          to each submodule (recursively)
          #              ``repo_urls`` - The respective url for each submodule (recursively)
          #*
          function git_airgap_submodule_update()
          (
            set -eu # fail fast

            # Strip trailing slash
            local submodule_path="${1%/}"

            # Find submodule in the list
            local repo_url
            if declare -p repos &>/dev/null; then
              repo_url="${repos["${submodule_path}"]}"
              unset repos
            else
              local index
              for index in "${!repo_paths[@]}"; do
                if [ "${repo_paths[$index]}" = "${submodule_path}" ]; then
                  repo_url="${repo_urls[$index]}"
                  break
                fi
              done
              unset repo_urls repo_paths
            fi
            if [ -z "${repo_url:+set}" ]; then
              echo "ERROR submodule_path, ${submodule_path}, not found in repo_paths:"
              for index in "${!repo_paths[@]}"; do echo "  ${repo_paths[$index]}"; done
              return 1
            fi

            # This follows just:git_mirror:git_clone_main
            git submodule init "${submodule_path}"
            git config "submodule.${submodule_path}.url" "${repo_url}"
            git submodule update "${submodule_path}"
          )
          '
}

#**
# .. function:: submodule-helper-relative-url
#
# Essentially ``git submodule--helper relative-url`` (if it existed)
#
# Resolve a submodule's relative URL based on the parent URL. This function works by creating a dummy git repository and submodule and then running ``git submodule init`` (which runs a process similar to ``git submodule sync``), after which, the resolved URL can be queried with ``git config submodule.submod.url``. We do this to avoid modifying the existing repository's git configuration (e.g., ``git config submodule.docker/recipes.url``).
#
# :Arguments: * ``$1`` - URL of the parent repository; e.g., ``git config remote.origin.url``
#             * ``$2`` - A relative submodule URL---typically from the .gitmodules file; e.g., ``git config -f .gitmodules submodule.docker/recipes.url``
#             * [``$3``] - Up path: path from the submodule to the parent repository; e.g., ``../../``. Must have a trailing slash
#
# :Output: *stdout* - Resolved URL
#
# .. note::
#
#   This is essentially a bash port of the function `relative_url() <https://github.com/git/git/blob/v2.16.0/builtin/submodule--helper.c#L117>`_ (called from `resolve_relative_url() <https://github.com/git/git/blob/v2.16.0/builtin/submodule--helper.c#L180>`_, aka ``git submodule--helper resolve-relative-url``, which itself is called from `cmd_sync() <https://github.com/git/git/blob/v2.16.0/git-submodule.sh#L1014>`_, aka ``git submodule sync``. ``git submodule--helper resolve-relative-url``, which is available in git 2.9 and after, does not allow us to specify (directly) the remote URL from which to resolve a relative URL: it resolves relative URLs based on the remote URL, ``git config remote.${remote_name}.url``, where remote_name is the default remote of the current branch, if set; otherwise origin.
#**

function submodule-helper-relative-url()
{
  local remote_url="${1}"
  local gitmodules_url="${2}"
  local up_path="${3-}" # Guaranteed by git to have a trailing slash

  # Replace ../../ with subdir/subdir/
  local sm_path="${up_path//..\//subdir/}submod"
  # Strip off one level
  sm_path="${sm_path/subdir\//}"

  # Work in an automatically deleting temporary directory
  local temp_repo
  make_temp_path temp_repo -d
  pushd "${temp_repo}" 1>/dev/null
    # Fake out a git repo and submodule. I need to know the URL tracked by
    # the .gitmodules file (because that is what is used when cloning the
    # repo). However, I can't use git config -f .gitmodules because the
    # path can (annoyingly) be a relative URL (either to a web address or
    # filesystem path) and I can't figure out any other way to expand it
    # other then running git submodule sync (or init if not already).
    # However, this will also "synchronize the submodules' remote URL
    # configuration setting to the value specified in .gitmodules". That is
    # to say, it updates the value in .git/config as well as the value in
    # .git/modules/docker/recipes/config, which is a problem we've run into
    # before: issue #186
    # RE In git v2.9.0, git submodule--helper resolve-relative-url, was
    # added to do this, but relative URLs exist as far back as v1.8.3
    # RE Actually, it seems the behavior of
    #   git submodule--helper resolve-relative-url
    # is less sophisticated than I expected (basically just a norm_path if
    # the host & rpath of the URL could be extracted easily. While
    # parser.bsh:parse_url exists, it doesn't handle the various URL formats
    # supported by git: e.g., ssh://git@, git@, etc.)
    ${GIT} init 1>/dev/null
    ${GIT} config remote.origin.url "${remote_url}"
    uwecho "[submodule \""${sm_path}"\"]
              path = "${sm_path}"
              url = ${gitmodules_url}" > .gitmodules
    mkdir -p "${sm_path}" .git/modules/"${sm_path}"/{objects,refs/heads}
    echo "gitdir: ../.git/modules/"${sm_path}"" > "${sm_path}"/.git
    echo "ref: refs/heads/master" > .git/modules/"${sm_path}"/HEAD
    echo "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" > .git/modules/"${sm_path}"/refs/heads/master

    # from https://stackoverflow.com/a/37378302
    ${GIT} update-index --add --cacheinfo 160000 aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa "${sm_path}" 1>/dev/null
    ${GIT} submodule init "${sm_path}" 2>/dev/null # REVIEW Why did I redirect stderr
    ${GIT} submodule sync "${sm_path}" 1>/dev/null

    if [ -n "${up_path}" ]; then
      pushd "${sm_path}" 1> /dev/null
        ${GIT} config --get remote.origin.url
      popd 1> /dev/null
    else
      ${GIT} config --get submodule.submod.url
    fi
  popd 1>/dev/null
}

#**
# .. function:: git_sync_submodules_recursively
#
# ``git submodule sync`` but using a specific remote (``just_upstream`` by default)
#
# Like ``git submodule sync``, synchronize the URL configuration setting of each submodule (recursively) to the value specified in .gitmodules; however, instead of overwriting the default remote (origin), update the remote specified by JUST_GIT_UPSTREAM (``just_upstream`` by default).
#
# :Arguments: [``$1``] - The top-level repository remote-name. Default: origin
# :Parameters: - [``JUST_GIT_UPSTREAM``] - The submodule remote-name. When updating the remote URL, use this remote. Default: ``just_upstream``
#
# .. note::
#
#   Creates the just_upstream remote just like, and using the same procedure as, :func:`just_git_functions.bsh safe_git_submodule_update`; however, importantly, it does not try to update the submodule to the expected SHA.
#**

# REVIEW just_git_functions.bsh:safe_git_submodule_update is broken. Use this
# function instead
function git_sync_submodules_recursively()
{
  local remote_name="${1-origin}"

  local JUST_GIT_UPSTREAM="${JUST_GIT_UPSTREAM-just_upstream}"

  local OLD_IFS="${IFS}"
  IFS=$'\n'
  # More robust than just_git_functions.bsh:submodule-helper-list
  local submodule_keys=($(get_submodule_names))
  #local tracked_shas=($(${GIT} submodule foreach --quiet 'echo "${prefix-"${displaypath}"}" ${sha1}'))
  IFS="${OLD_IFS}"

  local sm_key
  for sm_key in ${submodule_keys+"${submodule_keys[@]}"}; do
    local sm_path="$(${GIT} config -f .gitmodules "${sm_key}".path)"
    local sm_name="${sm_key#submodule.}"
    # Remove trailing slash
    sm_path="${sm_path%/}"
    local submodule_url="$(${GIT} config -f "${PWD}"/.gitmodules "${sm_key}".url)"
    # URLs/paths relative to the CWD must either start with ./ or ../
    # according to git. This is how git-submodule.sh checks for this:
    # https://github.com/git/git/blob/v2.16.0/git-submodule.sh#L1059
    if [[ "${submodule_url}" == "./"* ]] || [[ "${submodule_url}" == "../"* ]]; then
      # based on https://github.com/git/git/blob/v2.16.0/git-submodule.sh#L1060
      # rewrite foo/bar as ../.. to find path from
      # submodule work tree to superproject work tree
      local up_path="$(printf '%s\n' "$sm_path" | sed "s/[^/][^/]*/../g")"
      # guarantee a trailing /
      up_path=${up_path%/}/
      local remote_url="$(${GIT} config remote."${remote_name}".url)"
      # path from submodule work tree to submodule origin repo
      sub_origin_url="$(submodule-helper-relative-url "${remote_url}" "${submodule_url}" "${up_path}")"
      # path from superproject work tree to submodule origin repo
      #super_config_url=$(submodule-helper-relative-url "${remote_url}" "${submodule_url}")

      # No need to run git config submodule."${sm_name}".url "${super_config_url}"

      submodule_url="${sub_origin_url}"
    fi

    pushd "${sm_path}" &>/dev/null
      # See just_git_functions.bsh:safe_git_submodule_update:
      # This is my equivalent to "git submodule sync". It uses a specific remote
      # that it not one of the defaults to handle issue #186
      ${GIT} remote add "${JUST_GIT_UPSTREAM}" "${submodule_url}" &> /dev/null || \
        ${GIT} remote set-url "${JUST_GIT_UPSTREAM}" "${submodule_url}"
      # Depth-first traversal
      git_sync_submodules_recursively "${JUST_GIT_UPSTREAM}"
    popd &>/dev/null
  done
}

#**
# .. function:: recursively_check_submodules_are_public
#
# Ensure all submodules have pushed the necessary changes to their public repo
#
# Check each submodule (recursively) to see if the SHA tracked by its parent repository has been pushed to the URL tracked by the parent repository (per its .gitmodules file). Must be run from the root of a repository.
#
# :Parameters: - [``JUST_GIT_UPSTREAM``] - The submodule remote-name. When fetching a remote URL, use this remote. Default: ``just_upstream``
#
# :Output: Return 0 if, for each submodule (recursively), the changes tracked by the parent repository have been made public; otherwise, return 1
#
# .. note::
#
#   Creates a JUST_GIT_UPSTREAM remote. See :func:`git_sync_submodules_recursively`.
#
# .. note::
#
#   Cf. ``git push --recurse-submodules=check`` (available since git 1.8.0) will check for unpushed commits in a submodule for its current committed state in the parent project. However, this only seems to work if it is used with a set of outgoing commits that contains a change to a submodule. And, despite its name, it does not seem to recurse into submodules.
#**

function recursively_check_submodules_are_public()
{
  git_sync_submodules_recursively ${@+"${@}"}

  local recursive_index=-1 # HACKY
  local is_tracked_change_private=0
  _recursively_check_submodules_are_public
}

function _recursively_check_submodules_are_public()
{
  local JUST_GIT_UPSTREAM="${JUST_GIT_UPSTREAM-just_upstream}"

  local recursive_index=$((recursive_index+1))

  local OLD_IFS="${IFS}"
  IFS=$'\n'
  # More robust than just_git_functions.bsh:submodule-helper-list
  local submodule_keys=($(get_submodule_names))
  #local tracked_shas=($(${GIT} submodule foreach --quiet 'echo "${prefix-"${displaypath}"}" ${sha1}'))
  IFS="${OLD_IFS}"

  local sm_key
  for sm_key in ${submodule_keys+"${submodule_keys[@]}"}; do
    local sm_path="$(${GIT} config -f .gitmodules "${sm_key}".path)"
    local sm_name="${sm_key#submodule.}"
    # Remove trailing slash
    sm_path="${sm_path%/}"
    local tracked_sha="$(${GIT} submodule status --cached "${sm_path}" | cut -c2- | awk '{print $1}')"
    local submodule_url="$(${GIT} config -f "${PWD}"/.gitmodules "${sm_key}".url)"

    pushd "${sm_path}" &>/dev/null
      ${GIT} fetch "${JUST_GIT_UPSTREAM}"

      # git branch -r --contains SHA will show a list of remote/branch refs
      # that contain a SHA. If no remote/branch refs are returned, this means
      # the commit has not been pushed
      if [ "$(${GIT} branch -r --contains "${tracked_sha}" | grep "^  ${JUST_GIT_UPSTREAM}")" = "" ]; then
        echo "WARNING The commit tracked by the parent repository of the"
        echo "submodule, '${sm_name}', has not been pushed to the"
        echo "remote URL tracked by the parent repository:"
        echo "  ${submodule_url}"
        echo
        is_tracked_change_private=1
      fi

      # Depth-first traversal
      _recursively_check_submodules_are_public "${JUST_GIT_UPSTREAM}"
    popd &>/dev/null
  done

  if [ "${recursive_index}" -eq 0 ]; then
    return ${is_tracked_change_private}
  fi
}

#**
# .. function:: relocate_git_defaultify
#
# Git relocate plugin for just
#**

function relocate_git_defaultify()
{
  arg=$1
  shift 1
  case $arg in
    # Create a mirror of a git repository (which is not the same thing as a
    # clone) and all of its submodules (for a specific branch). The mirror is
    # based on the URL of a git remote in this clone---not directly on this
    # clone itself.
    #
    # REVIEW When just supports it, rename 'git export-repo --guided'
    git_export-repo-guided) # Walk through how to export a mirror of the git \
                            # repository, including all submodules, to a tarball
      if [ $# -eq 0 ]; then
        echo "Creating a mirror of a git repository (which is not the same"
        echo "thing as a clone) and all of its submodules (for a specific"
        echo "branch). The mirror is based on the URL for a git remote in this"
        echo "clone---not directly on this clone itself."
        echo
        echo "NOTE A question can be bypassed by adding the respective flag."
        echo "Add --help to see the flags."
        echo
      fi

      JUST_IGNORE_EXIT_CODES=3

      local check_remote
      local remote_name
      local prep_dir
      local branch
      local output_dir
      # In some versions of bash, these variables must explicitly be set to null
      unset check_remote
      unset remote_name
      unset prep_dir
      unset branch
      unset output_dir

      # REVIEW Switch to command_tools:parse_args
      # RE Doesn't support help or die on unprocessed flags/positional arguments,
      # so I'd have to have a while loop like this to deal with those anyway;
      # Also have to handle the --no- variant manually
      while (( $# )); do
        # Convert arguments of the form -f=val to -f val and --flag=val to --flag val
        # https://medium.com/@binaryphile/nice-one-elegant-in-its-simplicity-eee6b433bc90
        if [[ $1 == -?=* ]] || [[ $1 == --*=* ]]; then
          set -- "${1%%=*}" "${1#*=}" "${@:2}"
        fi
        case "$1" in
          -h|--help)
            echo "just git export-repo-guided [-b|--branch] [-c|--[no-]check-remote]"
            echo "                            [-r|--remote-name] [-p|--prep-dir]"
            echo "                            [-o|--output-dir] [-h|--help]"
            echo
            return 123
            ;;
          # The branch from which to identify the submodules
          -b|--branch)
            branch=$2
            extra_args+=2
            shift 2
            ;;
          # Check for unpushed commits
          -c|--check-remote)
            check_remote="1"
            extra_args+=1
            shift 1
            ;;
          # Don't check for unpushed commits
          --no-check-remote)
            check_remote="0"
            extra_args+=1
            shift 1
            ;;
          # Repository's remote name (e.g., origin)
          -r|--remote-name)
            remote_name=$2
            extra_args+=2
            shift 2
            ;;
          # NOTE Supporting remote_url is somewhat hard because the remote_name
          # must be looked up somehow
          #-u|--url)
          #  ;;
          # The directory to which the repo has previously been
          # mirrored; it acts as a cache
          -p|--prep-dir)
            prep_dir=$2
            extra_args+=2
            shift 2
            ;;
          # The directory in which to mirror the repo
          -o|--output-dir)
            output_dir=$2
            extra_args+=2
            shift 2
            ;;
          -*|--*)
            echo "Unknown flag: $1"
            return 123
            ;;
          *)
            echo "Positional arguments are not allowed: $1"
            return 123
            ;;
        esac
      done
      # Only prep_dir xor remote_name can be set
      if [ -n "${prep_dir+x}" ] && [ -n "${remote_name+x}" ]; then
        echo "Only one of --prep-dir and --remote-name can be given"
        return 123
      fi
      # Only prep_dir xor output_dir can be set
      if [ -n "${prep_dir+x}" ] && [ -n "${output_dir+x}" ]; then
        echo "Only one of --prep_dir and --output_dir can be given"
        return 123
      fi


      # NOTE if specifying a prep_dir, this isn't needed, but should probably
      # exist
      local valid_remote_names=($(${GIT} remote))
      if [ "${#valid_remote_names[@]}" -eq 0 ]; then
        # Either the repo is misconfigured or initialized locally.
        # REVIEW In the latter case at least, we could mirror the repo directly
        # RE We won't worry about that use case now
        echo "This repository has no remotes. Please push the repo to a"
        echo "git server and try again."
        return 123
      fi

      local remote_names
      unset remote_names
      # Are either remote_name or prep_dir provided as flags
      if [ -z "${remote_name+x}" ] && [ -z "${prep_dir+x}" ]; then
        echo "Would you like to:"
        picker "Create a new mirror from a remote's URL" \
               "Base off an existing airgap mirror (i.e., a PREP_DIR)" || picked=$?
        echo
        if [ "${picked}" -eq 1 ]; then
          local OLD_IFS="${IFS}"
          IFS=$'\n'
          remote_names=("${valid_remote_names[@]}")
          IFS="${OLD_IFS}"
        else
          # cd so that tab completion works
          pushd "${JUST_USER_CWD}" &>/dev/null
            read -r -e -p "Where is the existing mirror: " prep_dir
            echo
          popd &>/dev/null
        fi
      elif [ -n "${remote_name+x}" ]; then
        # Validate remote_name is a git remote
        if ! isin "${remote_name}" "${valid_remote_names[@]}"; then
          echo "ERROR Unknown git remote provided with flag --remote-name: ${remote_name}"
          return 123
        fi

        remote_names=("${remote_name}")
      elif [ -n "${prep_dir+x}" ]; then
        # Because prep_dir must always be validated, whether it was provided as
        # a flag or asked for, it is validated below
        :
      fi
      # remote_names or prep_dir is set


      local remote_url
      local remote_name
      if [ -n "${remote_names+x}" ]; then
        local associated_remote_urls=()
        local associated_remote_names=()
        for remote_name in "${remote_names[@]}"; do
          local OLD_IFS="${IFS}"
          IFS=$'\n'
          # List urls configured for git fetch (i.e., the urls in the
          # .git/config:[remote] section)
          # NOTE Since git 1.8, a remote (e.g., origin) can have multiple
          # associated urls (and pushurls) (see .git/config)
          #
          # Make the list unique, preserving order
          # https://stackoverflow.com/a/31038481
          # https://stackoverflow.com/a/17562858
          #
          # No quotes around subshell to create array (although IFS must be correct)
          local remote_urls=($(${GIT} config --get-all remote."${remote_name}".url | awk '!a[$0]++'))
          IFS="${OLD_IFS}"
          if [ "${#remote_urls[@]}" -eq 0 ]; then
            # This shouldn't happen; if the repo has a named remote, it should
            # have an associated remote url
            echo "ERROR This repository is misconfigured: it has no urls for remote '${remote_name}'."
            echo "Please fix!"
            return 123
          fi
          associated_remote_urls+=("${remote_urls[@]}")
          local i
          for i in "${!remote_urls[@]}"; do
            associated_remote_names+=("${remote_name}")
          done
        done
        if [ "${#associated_remote_names[@]}" -ne "${#associated_remote_urls[@]}" ]; then
          echo "ASSERT These two arrays are expected to have the same length"
          return 123
        fi

        if [ "${#associated_remote_urls[@]}" -eq 0 ]; then
          # This shouldn't happen; if the repo has a named remote, it should
          # have an associated remote url
          # This actually should be impossible now because we ensure each remote
          # has at least 1 url (consequently, cannot test)
          echo "ERROR This repository is misconfigured: it has no remote urls."
          echo "Please fix!"
          return 123
        elif [ "${#associated_remote_urls[@]}" -eq 1 ]; then
          remote_name="${associated_remote_names[0]}"
          remote_url="${associated_remote_urls[0]}"
          echo "Using remote: '${remote_name}' located at"
          echo "   ${remote_url}"
          echo
        elif [ "${#associated_remote_urls[@]}" -gt 1 ]; then
          local remote_strings=()
          local i
          for i in "${!associated_remote_urls[@]}"; do
            remote_strings+=("$(printf "%s\t%s\n" "${associated_remote_names[$i]}" "${associated_remote_urls[$i]}")")
          done

          local default_remote="$(printf "%s\t%s\n" origin "$(${GIT} config remote.origin.url)")"
          local default_index="$(findin "${default_remote}" "${remote_strings[@]}")"

          echo "Please choose a remote:"
          local picked
          DEFAULT_RESPONSE="${default_index}" picker "${remote_strings[@]}" || picked=$?
          echo
          remote_name="${associated_remote_names[picked-1]}"
          remote_url="${associated_remote_urls[picked-1]}"
        fi
      elif [ -n "${prep_dir+x}" ]; then
        # Validate this looks like a prep_dir; this is how git_mirror_main
        # computes this variable
        if [ -f "${JUST_USER_CWD}/${prep_dir}/"*"/config" ]; then
          pushd "$(dirname "${JUST_USER_CWD}/${prep_dir}/"*"/config")" &> /dev/null
            # This is the only remote that exists in the prep_dir
            remote_name="origin"
            remote_url="$(${GIT} config --get remote.origin.url)"
            # Simply treat the prep_dir as the output_dir
            # REVIEW I do this primarily because the the rest of this target
            # assumes it is operating on this repository.
            output_dir="${prep_dir}"
            unset prep_dir
          popd &> /dev/null
        else
          echo "ERROR ${prep_dir} does not look like a PREP_DIR"
          return 123
        fi
      fi


      # Branch names cannot have spaces
      local valid_branches=($(${GIT} for-each-ref --format='%(refname:short)' refs/heads))
      if [ "${#valid_branches[@]}" -eq 0 ]; then
        echo "ERROR This repository is misconfigured: it has no branches."
        echo "Please fix!"
        return 123
      fi

      local branch
      # Is branch provided as a flag
      if [ -z "${branch+x}" ]; then
        local branch
        # List local branches (branch names cannot have spaces)
        branches=("${valid_branches[@]}")
        if [ "${#branches[@]}" -eq 1 ]; then
          branch="${branches[0]}"
          echo "Using the only branch in this repository: '${branch}'"
          echo
        else
          local current_branch="$(${GIT} rev-parse --abbrev-ref HEAD)"
          default_index="$(findin "${current_branch}" "${branches}")"

          local picked
          echo "Please choose which branch you would like to base the submodules off:"
          DEFAULT_RESPONSE="${default_index}" picker "${branches[@]}" || picked=$?
          echo
          branch="${branches[picked-1]}"
        fi
      elif [ -n "${branch+x}" ]; then
        # Validate branch is a git branch
        if ! isin "${branch}" "${valid_branches[@]}"; then
          echo "ERROR Unknown git branch provided with flag --branch: ${branch}"
          return 123
        fi
      fi


      # Is check_remote set by a flag
      if [ -z "${check_remote+x}" ]; then
        ask_question "Do you want to ensure all local changes have been pushed to '${remote_name}'" \
            check_remote y
        echo
      fi
      if [ "${check_remote}" == "1" ]; then
        local sm_status_rv=0
        local sm_status
        # Calls git fetch; connecting to the URL is required when creating the
        # mirror, so this is ok
        # local foo="$(bar)" || rv=$? does not work as one line in bash 4.2 or older. Ues two lines
        sm_status="$(recursively_check_submodules_are_public "${remote_name}")" || \
            sm_status_rv=$?
        if [ "${sm_status_rv}" -ne 0 ]; then
          echo "${sm_status}"
          echo
        fi
        # No need to call git fetch in the top-level repository
        unpushed_commits="$(log_unpushed_commits "${remote_name}" "${branch}")"
        if [ "${unpushed_commits}" != "" ]; then
          echo "WARNING In this repo, ${unpushed_commits/There are/there are}"
          echo
        fi
        if [ "${sm_status_rv}" -ne 0 ] || [ "${unpushed_commits}" != "" ]; then
          echo "WARNING There are unpushed changes. You may want to ensure all"
          echo "changes to this repository and its submodules have been pushed"
          echo "to their respective remote servers."
          ask_question "Continue?" response n
          [ "$response" == "0" ] && return 123
        fi
      fi


      # Is output_dir unset; i.e., it was not set either as a flag or inferred
      # from prep_dir
      if [ -z "${output_dir+x}" ]; then
        # cd so that tab completion works
        pushd "${JUST_USER_CWD}" &>/dev/null
          # REVIEW After all this, the user could choose an output_dir which is
          # a prep_dir
          # RE I guess that would be ok though
          echo "Where would you like the mirror to be created"
          read -r -e -p \
              "Note: keep this directory as a cache and reuse it during future mirrors: " \
              output_dir
          echo
        popd &>/dev/null
      fi
      # REVIEW Could test to ensure output_dir either doesn't exist or is empty

      justify git_export-repo "${remote_url}" "${branch}" "${output_dir}"
      ;;

    # REVIEW Rename to git_mirror-repo and git_push-airgap-repo
    # NOTE this is tightly coupled with git_import-repo
    git_export-repo) # Export a mirror of the git repository, including all \
                     # submodules, to a tarball
      # REVIEW Move this functionality into a function

      # ASSUMPTION We are currently in the project's root directory; this is
      # normally the case with just

      local args=(${@+"${@}"})
      # If no arguments are specified, choose origin's (last) remote URL
      if [ "${#args[@]}" -eq 0 ]; then
        local remote_url=$(${GIT} config --get remote.origin.url)
        args=("${remote_url}")
      fi

      # just cd's into the project's root directory, which will make
      # prep_dir/output_dir relative to that, not the user's CWD
      pushd "${JUST_USER_CWD}" &>/dev/null
        local GIT_MIRROR_PREP_DIR
        local GIT_MIRROR_MAIN_REPO
        # Sets GIT_MIRROR_PREP_DIR and GIT_MIRROR_MAIN_REPO
        git_mirror_repos "${args[@]}"
      popd &>/dev/null

      # Find the name of the top-level repo according to the remote url
      # This is how git_mirror_main computes this variable
      local repo_name="$(basename "${GIT_MIRROR_MAIN_REPO}")"
      repo_name="${repo_name%.*}"

      # Create the file that maps between the submodule's path and its new URL.
      # This mapping MUST be created in this repo because the mirror in the
      # prep_dir does not have its submodules recursively updated
      create_repo_map "${repo_name}" > "${GIT_MIRROR_PREP_DIR}/repo_map.env"

      # Copy a simple Justfile to make import-repo easy
      add_import-repo_just_project "${GIT_MIRROR_PREP_DIR}"

      # Archive the mirrored repos
      archive_mirrors "${GIT_MIRROR_PREP_DIR}"

      extra_args=$#
      ;;

    # NOTE this is tightly coupled with git_export-repo
    git_import-repo) # Push a repo exported with `git export-repo` to an \
                     # initialized git repo
      # REVIEW Move this functionality into a function

      # ASSUMPTION The bare repos for the submodules have been initialized
      # ASSUMPTION We are using the simple just project setup by
      # add_import-repo_just_project in git_export-repo, and are therefore
      # currently in the PREP_DIR

      # This is how git_push_main computes this variable
      local main_dir="$(dirname "$(ls */config)")"

      repo_map="$(cat repo_map.env)"

      # Orphan commit the repo_map.env file so it is available going forward;
      # e.g., during git_clone-airgap-repo
      pushd "${main_dir}" &>/dev/null
        orphan_commit_repo_map "${repo_map}"
      popd &>/dev/null

      git_push_main repo_map.env ./
      ;;

    git_clone-airgap-repo) # Clone a repo exported with `git export-repo`. This \
                           # is necessary because we do not want to update the \
                           # url's of the submodules
      # NOTE setup.env must be edited to include logic to init and update
      # vsi_common (basically copying part of git_clone_main) before this
      # target can be called

      local repo_map_file
      make_temp_path repo_map_file # auto-deleting file
      # The repo map's submodule URLs were corrected in git_import-repo
      git show origin/__just_git_mirror_info_file:repo_map.env > "${repo_map_file}"
      git_clone_main "${repo_map_file}" ./
      ;;

    # TODO Move to just_git_functions
    git_unpushed-commits) # List unpushed commits on a branch
      if ! command -v ${GIT} >& /dev/null; then
        echo "Git not found, skipping listing of unpushed commits" >&2
        return 0
      fi

      log_unpushed_commits ${@"${@}"}
      ;;

    # TODO Move to just_git_functions
    git_outgoing-commits) # List outgoing commits on a branch
      if ! command -v ${GIT} >& /dev/null; then
        echo "Git not found, skipping listing of outgoing commits" >&2
        return 0
      fi

      log_outgoing_commits ${@"${@}"}
      ;;

    # TODO Move to just_git_functions
    git_make-remote-url-pushable) # Change the remote urls to use the git@ \
                                   # syntax instead of https
      if ! command -v ${GIT} >& /dev/null; then
        echo "Git not found, skipping remote url conversion" >&2
        return 0
      fi

      make_remote_url_pushable
      ;;

    *)
      plugin_not_found=1
      ;;
  esac
  return 0
}
