#!/usr/bin/env false bash

if [[ $- != *i* ]]; then
  source_once &> /dev/null && return 0
fi

JUST_DEFAULTIFY_FUNCTIONS+=(relocate_git_defaultify)
JUST_HELP_FILES+=("${BASH_SOURCE[0]}")

#*# just/plugins/just_git_airgap_repo

#**
# .. default-domain:: bash
#
# ===============================================
# J.U.S.T. Git Mirror to an Air-gapped Repository
# ===============================================
#
# .. file:: just_git_airgap_repo.bsh
#
# While creating a git mirror is as simple as ``git clone --mirror``, unfortunately this git command does not support git submodules or lfs. These functions help in creating and subsequently cloning a mirror of a project with submodules and/or git lfs.
#
# .. rubric:: Example
#
# Mirror a repository and push it to a new air-gaped git server:
#
# 1. ``just git export-repo https://github.com/visionsystemsinc/vsi_common.git master ~/vsi_common_prep`` - Mirror the repository and recursively create mirrors of all submodules currently in the master branch.
# 2. Transfer ``vsi_common_prep/transfer_{date}.tgz`` to your destination.
# 3. Extract the archive
#   a) In vsi_common_prep, edit airgap.env and set the environment variables. For example,
#     - JUST_GIT_AIRGAP_SERVER=https://git-server.com/
#     - JUST_GIT_AIRGAP_ORGANIZATION=projectA
# 4. If not already, initialize bare repositories on the air-gapped git server for vsi_common and its submodule, recipes. In this example, these should be located at
#   - https://git-server.com/projectA/vsi_common
#   - https://git-server.com/projectA/recipes
# 5. ``source setup.env``
# 6. ``just git import-repo`` - Push the mirrored repository and all submodules to a new git server as defined by repo_map.env
# 7. Incremental updates can be pushed to the repositories using much the same process. See :file:`git_mirror_main`.
#
# A developer can then run:
# 1. ``git clone https://git-server.com/projectA/vsi_common.git``
# 2. ``just git clone-airgap-repo`` - Clone submodules recursively from the new mirror
#
# Note however, that a project that uses vsi_common as a submodule must add support in the setup.env file to initialize and update the vsi_common submodule before this target can be called.
#
# .. seealso::
#   :file:`git_mirror`: :func:`git_mirror_main`, :func:`git_push_main`, and :func:`git_clone_main`
#**

source "${VSI_COMMON_DIR}/linux/ask_question"
source "${VSI_COMMON_DIR}/linux/git_mirror"
source "${VSI_COMMON_DIR}/linux/uwecho.bsh"
source "${VSI_COMMON_DIR}/linux/parser.bsh"

#**
# .. envvar:: GIT
#
# Name/path of git executable
#
# Instead of hard-coding "git" everywhere, use the variable :envvar:`GIT` so that when the need comes, it is easier to switch which executable gets called. Set to empty string to have any calls to git skipped.
#
# All :func:`relocate_git_defaultify` targets will be skipped if the value of :envvar:`GIT` is not found or empty.
#
# .. note::
#   When using the GIT env variable in this file, do not surround it with quotes as you normally would. Although this prevents using a path to ``git`` with a space in it, in exchange, it may be possible (eventually) to enable a dry-run-ish capability if GIT is set to 'echo git'.
#**

: ${GIT=git}


# Unit Tests
# NOTE a tracking branch must actually be setup
# nothing unpushed - branch (non-tracking) behind origin/master
# nothing unpushed - branch (non-tracking) equal to origin/master
# unpushed commits - branch (non-tracking) ahead of origin/master
# no outgoing commits - tracking_branch is behind its tracked origin/tracking_branch
# no outgoing commits - tracking_branch is behind its tracked origin/master
# no outgoing commits - tracking_branch is equal to its tracked origin/tracking_branch
# outgoing commits - tracking_branch is ahead of its tracked origin/tracking_branch
# outgoing commits - tracking_branch is ahead of its tracked origin/master
# ignore outgoing commits - remote-tracking branch removed, but the local-tracking branch remains
# ignore outgoing commits - no tracking branches


#**
# .. function:: log_unpushed_commits
#
# List all unpushed commits to stdout
#
# List all commits on branches that have not been pushed to a remote. This is a set operation: it lists all the commits from a branch in the DAG except those reachable by a remote-tracking branch. It does not require an *associated* remote-tracking branch
#
# REVIEW What order should these go in
# :Arguments: - ``1`` - A branch's name to filter by; e.g., master. If unset, then don't filter
#             - ``2`` - A name of a remote to filter by; e.g., origin. If unset, then don't filter
#
# :Output: - ``*stdout*`` - Print all unpushed commits for tracking branches to stdout
#**

function log_unpushed_commits()
{
  # NOTE Only supports passing in a single branch and named remote
  local branch="${1---branches}"
  local remote_name="${2-}"

  local commits="$(${GIT} log --decorate --graph --format=short --color=always \
      "${branch}" --not --remotes="${remote_name}")"
  echo "${commits}"
}

#**
# .. function:: git_tracking_branches
#
# Find remote- and corresponding local-tracking branches
#
# :Arguments: - ``1`` - A name of a remote to filter by; e.g., origin. If unset, then don't filter
#
# :Output: - ``just_git_tracking_branches`` - An array of local-tracking branch names
#          - ``just_git_remote_tracking_branches`` - A corresponding array of remote-tracking branch names
#
# .. note::
#    - A branch that you create locally and then push to a remote is not configured as a local-tracking branch by default. You must use the -u flag with 'git push' or 'git branch'.
#   - A branch cannot track multiple remotes.
#   - Requires git >= 1.9.0
#**

function git_tracking_branches()
{
  # REVIEW Could support multiple named remotes with a for loop
  local remote_name="${1-}"

  local OLD_IFS="${IFS}"
  IFS=$'\n'
  # E.g., upstream:short=origin/master, refname=refs/heads/master and
  # upstream:track=[gone] if the remote-tracking branch has been pruned
  # NOTE %(upstream:track) requires git >= 1.9.0
  # NOTE No quotes around subshell to create array
  local tracking_branches=($( \
      ${GIT} for-each-ref --format='%(upstream:short) %(refname) %(upstream:track)' refs/heads | \
      # Discard lines in which upstream is unset, i.e., those with a leading space
      # RE this seems brittle
      # Also trim whitespace at the end of each line
      # TODO Switch to string_tools.bsh:rtrim
      grep -v '^ ' | grep -v '\[gone\]$' | grep "^${remote_name}" | sed 's/[[:space:]]+$//' || :))
  IFS="${OLD_IFS}"
  #
  # Similarly: git rev-parse --abbrev-ref branch@{upstream} will also give the
  # tracking branch (or error if one doesn't exist or has been pruned). This
  # can be combined with git for-each-ref --format='%(refname:short)' refs/heads
  # which lists all local branches.
  # Alternatively: git branch -vv provides the same tracking information as
  # upstream:track, even in git 1.8.3
  # RE this is the only command to get this info in git 1.8.3; although it can
  # be calculated manually with git log --format='%H' branch@{upstream}..branch
  # for outgoing commits and git log --format='%H' branch..branch@{upstream}
  # for incoming
  # RE git rev-list --left-right --boundary branch@{upstream}...branch lists
  # both incoming and outgoing changes as well (the symmetric difference)
  # git remote show origin actually queries the remote; however, it doesn't
  # provide the same level of tracking detail

  just_git_tracking_branches=()
  just_git_remote_tracking_branches=()
  for tracking_branch in ${tracking_branches+"${tracking_branches[@]}"}; do
    local branch="$(echo "${tracking_branch}" | awk '{print $2}')"
    # Strip refs/heads prefix from the remoteref
    just_git_tracking_branches+=("${branch/refs\/heads\//}")
    just_git_remote_tracking_branches+=("$(echo "${tracking_branch}" | awk '{print $1}')")
  done
}

#**
# .. function:: log_outgoing_commits
#
# List all unpushed commits for a tracking branches to stdout
#
# REVIEW What order should these go in
# :Arguments: - ``1`` - A local-tracking branch's name to filter by; e.g., master. If unset, then don't filter by branch name
#             - ``2`` - A name of a remote to filter by; e.g., origin. If unset, then don't filter
#
# :Output: - ``*stdout*`` - Print all unpushed commits for tracking branches to stdout
#
# .. note:: A branch cannot track multiple remotes.
#**

function log_outgoing_commits()
{
  # NOTE Only supports passing in a single branch and named remote
  local remote_name="${2-}"

  local tracking_branches
  if [ $# -eq 0 ]; then
    git_tracking_branches "${remote_name}" # Sets just_git_tracking_branches
    tracking_branches=("${just_git_tracking_branches[@]}")
  else
    tracking_branches=("${1}")
  fi

  # This will list only the outgoing commits for a local-tracking branch
  local tracking_branch
  local commits=()
  for tracking_branch in "${tracking_branches[@]}"; do
    commits+=("$(${GIT} log --decorate --graph --format=short --color=always \
        "${tracking_branch}"@{upstream}.."${tracking_branch}")")
  done
  local OLD_IFS="${IFS}"
  IFS=$'\n'
  echo "${commits[*]}"
  IFS="${OLD_IFS}"
}

#**
# .. function:: submodule_summary
#
# Compare the expected commit of each submodule to its current working tree
#
# Using ``git diff --submodule=log``, compare the working tree of each submodule to the version commited to HEAD of the super project, and list any commits that are missing and/or now present in the submodule. For example, if an earlier commit in the submodule is checked out, there will be missing commits in the submodule according to the super project. Similarly, if a commit is made to the submodule, there will be new commits present in the submodule according to the super project. Of course, the commit graph could diverge in more complicated ways.
#
# :Output: - ``*stdout*`` - Each submodule's differences in terms of commits
#
# .. seealso:: https://git-scm.com/docs/git-diff#Documentation/git-diff.txt---submoduleltformatgt
#
# TODO Support iterating through all submodules
#**

function submodule_summary()
{
  local OLD_IFS="${IFS}"
  IFS=$'\n'
  for x in $(${GIT} config --name-only --file .gitmodules --get-regexp '^submodule\..*\.path$'); do
    ${GIT} diff --submodule=log "$(${GIT} config --file .gitmodules --get "${x}")"
  done
  IFS="${OLD_IFS}"
}

# 'git push --recurse-submodules=check' (available in git 1.8.0) will check for unpushed commits in a submodule for its current committed state in the parent project
# RE 'git config push.recurseSubmodules check' (available in git 2.7.0)

#**
# .. function:: make_remote_urls_pushable
#
# Change the remote url of a git repo to use the git@ syntax instead of https
#
# Query the git repository's remotes; if the URL of the remote is specified using the the https:// protocol, convert it to the ssh transfer protocol (git@..) to make pushing changes to the remote server easier. Assume a very basic url format: https://git-server.com/co/project.git without port, query, or fragment sections. Warn if these exist
#
# :Arguments: - ``1`` - A name of a remote to filter by; e.g., origin. If unset, then don't filter
#
# .. note::
#  This does not change the submodule's tracked URL, i.e., the URL in the .gitmodules file, only the url in .git/config
#**

function make_remote_urls_pushable()
{
  local specified_remote_name="${1-}"

  local remote
  ${GIT} remote -v | grep '(push)$' | while read remote;
  do
    local remote_name
    local remote_url
    read -r remote_name remote_url <<< "$(echo "${remote}" | awk '{print $1 " " $2}')"
    if [ -n "${specified_remote_name}" ] && \
       [ "${specified_remote_name}" != "${remote_name}" ]; then
      continue
    fi

    local remote_git_url_rv=0
    local remote_git_url
    # local foo="$(bar)" || rv=$? does not work as one line in bash 4.2 or older. Ues two lines
    remote_git_url="$(_https_to_git_protocol "${remote_url}")" || remote_git_url_rv=$?
    if [ "${remote_git_url_rv}" == "0" ]; then
      # NOTE since git 1.8, a remote (e.g., origin) can have multiple associated
      # pushurls (see .git/config)
      # RE providing the old url (remote_url) will update the correct url
      ${GIT} remote set-url "${remote_name}" --push "${remote_git_url}" "${remote_url}"
    else # See if URL is already in the expected format
      # This is very simple; basically undo the simple transform done here.
      # Perhaps one day we will have a git remote url parser in parser.bsh
      local remote_https_url="$(echo "${remote_url}" | sed -e 's#^git@#https://#' -e 's#:#/#3')"
      if ! parse_url "${remote_https_url}"; then
        echo "WARNING URL is non-standard. Skipping ${remote_url}"
      fi
    fi
  done
}

function _https_to_git_protocol()
{
  local remote_url="${1}"

  # Be very conservative about which URLs will convert
  # NOTE If the git server has a non-standard port (which would not be the
  # same as https port), you have to do ssh://git@server:port/...
  if parse_url "${remote_url}"; then # Sets just_url_parsed_host, just_url_parsed_rpath, etc.
    if [ "${just_url_parsed_port}" != "" ] || \
       [ "${just_url_parsed_query}" != "" ] || \
       [ "${just_url_parsed_fragment}" != "" ]; then
      echo "${remote_url}"
      return 1
    elif [ "${just_url_parsed_scheme}" == "http" ] || \
         [ "${just_url_parsed_scheme}" == "https" ]; then
      local remote_git_url="git@${just_url_parsed_host}:${just_url_parsed_rpath}"
      echo "${remote_git_url}"
    fi
  else
    echo "${remote_url}"
    return 1
  fi
}

# Similar to git rev-parse --show-superproject-working-tree
# This won't work if the git-dir is separate
function toplevel()
{
   realpath "$(${GIT} rev-parse --git-dir)" | awk -F '/.git' '{print $1}'
}

# Get the (relative) path from the top-level repository to the submodule
#
# NOTE The submodules must have been checked out recursively (which is obviously
# not the case in a bare/mirror repo)
function get_submodule_paths_recursively()
{
  # At some point, prefix was deprecated and removed in favor of displaypath
  # NOTE prefix/displaypath only provides the expected path if this command is
  # run from the root of the top-level repository. Fortunately, that is the case
  # in the Justfile.
  # Alternatively, add JUST_PROJECT_DIR to just or use :func:`toplevel`
  ${GIT} submodule foreach --quiet --recursive 'echo ${prefix-${displaypath}}'
}

# Get all submodule urls
#
# NOTE The submodules must have been checked out recursively (which is obviously
# not the case in a bare/mirror repo)
#
# REVIEW This gets the url for the origin. The correct url is the one tracked
# by the .gitmodules file
# RE git_mirror does this
#   git config submodule.docker/recipes.url
# which reads the url in the config file, and
#   git config -f .gitmodules submodule.docker/recipes.url
# to read what is in the .gitmodules file
function get_submodule_urls_recursively()
{
  # REVIEW Should i unset GIT_DIR?
  ${GIT} submodule foreach --quiet --recursive \
      "export GIT; bash -euc 'echo \"\$(${GIT} config --get remote.origin.url)\"'"
}

#**
# Create the contents of the repo_map.env file
#
# Create the repository mapping such that it can be serialized by :func:`git_push_main` and :func:`git_clone_main` in :file:`git_mirror`.
#
# :Argument: ``$1`` - The top-level repository name (e.g., vsi_common)
#
# :Output: *stdout* - The contents of the repo_map.env file. For example,
#
# .. code-block:: bash
#
# repo_paths=(
#   ./
#   ./docker/recipes
# )
# repo_urls=(
#   '${JUST_GIT_AIRGAP_SERVER}/${JUST_GIT_AIRGAP_ORGANIZATION}'/vsi_common.git
#   '${JUST_GIT_AIRGAP_SERVER}/${JUST_GIT_AIRGAP_ORGANIZATION}'/recipes.git
# )
#
# Note that the urls are specified with env variables :envvar:`JUST_GIT_AIRGAP_SERVER` and :envvar:`JUST_GIT_AIRGAP_ORGANIZATION` which will expand to the mirrored repositories' new locations on the air-gapped git server; e.g., https://git-server/vsi/vsi_common.git and https://git-server/vsi/recipes.git.
#
# .. note:: The user can override this function if it does not suit her needs
#**

function create_repo_map()
{
  local repo_name="${1}"

  local OLD_IFS="${IFS}"
  IFS=$'\n'
  # No quotes around subshell to create array (although IFS must be correct)
  local repo_paths=("${repo_name}" $(get_submodule_paths_recursively))
  IFS="${OLD_IFS}"

  local repo_path
  local repo_urls=()
  for repo_path in "${repo_paths[@]}"; do
    # NOTE Quotes around JUST_AIRGAP_GIT_SERVER and JUST_GIT_AIRGAP_ORGANIZATION
    # aren't necessary here because the entries will be quoted when printed to
    # file
    repo_urls+=('${JUST_GIT_AIRGAP_SERVER}/${JUST_GIT_AIRGAP_ORGANIZATION}'/$(basename "${repo_path}")'.git')
  done
  # Rename the top-level repo to '.'
  repo_paths[0]='.'

  # Ugh
  printf '# NOTE: This file is automatically created by\n'
  printf '#   just:just_git_airgap_repo.bsh:create_repo_map\n'
  printf '#\n'
  printf '# If this mapping between submodules and URLs does not suit your\n'
  printf '# needs, you can edit this file directly before calling\n'
  printf '# `just git import-repo` or override `create_repo_map` before calling\n'
  printf '# `just git export-repo`\n'
  printf '\n\n'
  # This is not as nice as if the script would die automatically when it is
  # sourced if an env variable is null, but that doesn't seem possible;
  # set -u only check for unset variables, not null
  printf '# Error if these env variables are unset\n'
  printf ': ${JUST_GIT_AIRGAP_SERVER:?"UNSET: Please set in ./airgap.env"}\n'
  printf ': ${JUST_GIT_AIRGAP_ORGANIZATION:?"UNSET: Please set in ./airgap.env"}\n'
  printf '\n'
  print_repo_map
}

#**
# Output a string that can be saved as the repo_map.env file
#
# Serialize the repository mapping such that it can be sourced by
# :func:`git_push_main` and :func:`git_clone_main` in :file:`git_mirror`.
#
# :Arguments: repo_paths - The (relative) path from the top-level repository to each submodule (recursively)
#             repo_urls - The respective url for each submodule (recursively)
#
# :Output: *stdout* - The contents of the repo_map.env file
#**

function print_repo_map()
{
  printf 'repo_paths=(\n'
  printf '  "%s"\n' "${repo_paths[@]}"
  printf ')\n\n'
  printf 'repo_urls=(\n'
  printf '  "%s"\n' "${repo_urls[@]}"
  printf ')\n'
}

# Given a repo_map like the one produced by :func:`create_repo_map`, make an
# orphan commit in the repo (on a branch named __just_git_mirror_info_file by
# default) to a file named repo_map.env. An intermediate product of this
# function is a shallow clone of the current repo to a directory called
# __just_git_clone, which is removed at the end of the function
function orphan_commit_repo_map
{
  repo_map="${1}"
  orphan_branch="${2-__just_git_mirror_info_file}"

  # Clone (non-recursively) the repo in which to make the orphan commit.
  # Supports starting in a bare repo. Also avoids possibly needing to run
  # 'git reset --hard' after checking out the orphan branch followed by
  # 'git checkout' after committing to it.
  # NOTE Uses hard-links on linux
  # TODO Clone into an automatically deleting temporary directory; requires
  # mktemp_compat from dir_tools.bsh
  # RE this temp dir does not auto-delete
  if ls -A __just_git_clone &>/dev/null; then
    echo "The temporary directory, ./__just_git_clone, already exists and is"
    echo "not empty. This script will delete it and continue."
    ask_question "Is that ok?" answer_delete n
    [ "$answer_delete" == "0" ] && return 1
    rm -rf __just_git_clone
  fi
  ${GIT} clone --no-checkout ./ __just_git_clone
  pushd __just_git_clone &>/dev/null
    # Avoids checking out the files in the previously checked-out branch
    # and staging them for deletion when switching to a new (orphan) branch,
    # which then requires running 'git reset --hard' and/or 'git rm -rf .'
    # REVIEW I can't find a better way to do this
    rm .git/refs/heads/*
    ${GIT} checkout "${orphan_branch}" 2>/dev/null || \
        ${GIT} checkout --orphan "${orphan_branch}"

    echo "${repo_map}" > repo_map.env

    ${GIT} add repo_map.env && \
        git -c "user.name=just git_export-repo" \
            -c "user.email=<just@export-repo.git>" commit \
        --allow-empty \
        -m "the repo_map.env file needed by just:git_mirror that maps repo_paths to urls"
    ${GIT} push --force origin "${orphan_branch}"
  popd &>/dev/null
  rm -rf __just_git_clone
  #
  # ALTERNATIVELY
  #current_branch="$(git rev-parse --abbrev-ref HEAD)"
  #${GIT} checkout "${orphan_branch}" 2>/dev/null || \
  #     ${GIT} checkout --orphan "${orphan_branch}"
  #git reset --hard # This is important if "${orphan_branch}" was just created
  #
  #echo "${repo_map}" > repo_map.env
  #
  #${GIT} checkout "${current_branch}" # This could be expensive
}

# Creates a simple Justfile, setup.env, and airgap.env in the prep_dir
function add_import-repo_just_project()
{
  prep_dir="$(realpath "${1}")"

  # git archive external/vsi_common to ${prep_dir}/.vsi_common; does not include
  # submodules, but that that's ok
  pushd external/vsi_common &>/dev/null
    git archive --format=tar --prefix=.vsi_common/ HEAD | (cd "${prep_dir}" && tar xf -)
  popd &>/dev/null

  uwecho 'These mirrored git repositories were automatically created by

            just:just_git_airgap_repo:git_export-repo

          To push them to their respective air-gapped git servers, simply:

          1. Edit airgap.env to set a few environment variables
             or (if necessary)
             Edit repo_map.env directly
          2. `source setup.env`
          3. `just git import-repo`
          ' > "${prep_dir}"/README.md
  # REVIEW It might be nicer not to import a plugin here so that there is only
  # one target in just help
  uwecho '#!/usr/bin/env bash

          source "${VSI_COMMON_DIR}/linux/just_env" "$(dirname "${BASH_SOURCE[0]}")"/'airgap.env'
          source "${VSI_COMMON_DIR}/linux/just_git_airgap_repo.bsh"

          cd "${AIRGAP_MIRROR_CWD}"
          function caseify() { defaultify ${@+"${@}"}; }
          ' > "${prep_dir}"/Justfile
  # REVIEW If someone overrides create_repo_map, these env vars may not need
  # to be set--so don't explicitly error here. Currently, these variables are
  # checked in repo_map.env, and the script will then die because set -eu is
  # enabled by just
  # REVIEW Could merge airgap.env and repo_map.env
  # REVIEW Should these env variables use the ': ${VAR=}' syntax
  uwecho 'JUST_PROJECT_PREFIX=AIRGAP_MIRROR
          JUST_VERSION="'"${JUST_VERSION}"'"
          if [ -z "${AIRGAP_MIRROR_CWD+set}" ]; then
            AIRGAP_MIRROR_CWD="$(\cd "$(\dirname "${BASH_SOURCE[0]}")"; \pwd)"
          fi

          ### YOU MUST SET THESE VARIABLES ###
          # For example:
          # JUST_GIT_AIRGAP_SERVER=git@git-server.com: # Note the : at the end
          # JUST_GIT_AIRGAP_ORGANIZATION=projectA
          JUST_GIT_AIRGAP_SERVER=
          JUST_GIT_AIRGAP_ORGANIZATION=
          ' > "${prep_dir}"/airgap.env
  uwecho 'export JUST_SETUP_SCRIPT="$(basename "${BASH_SOURCE[0]}")"
          source "$(dirname "${BASH_SOURCE[0]}")/.vsi_common/env.bsh"
          unset JUSTFILE
          ' > "${prep_dir}"/setup.env
}

# After (shallow) cloning the air-gapped repository, the submodules must be
# re-configured and initialized/updated (recursively). This is handled by the
# git_clone-airgap-repo just target. However, this is not possible without the
# vsi_common submodule, which must first be initialized and updated.
#
# This function prints a function, git_airgap_submodule_update, which is
# appended to repo_map.env and orphan committed in the git_import-repo just
# target. git_airgap_submodule_update follows the same steps as
# git_mirror:git_clone_main.
#
# In order to call git_airgap_submodule_update, repo_map.env must be grabbed
# out of the orphan commit and then sourced. Obviously no just functions can
# be called yet, so this must be done in the file specified by
# :envvar:`JUST_SETUP_SCRIPT` (typically called setup.env). For example, the
# setup.env script, which typically looks like:
#
#   export JUST_SETUP_SCRIPT="$(basename "${BASH_SOURCE[0]}")"
#   source "$(dirname "${BASH_SOURCE[0]}")/external/vsi_common/env.bsh"
#
# would become:
#
#   export JUST_SETUP_SCRIPT="$(basename "${BASH_SOURCE[0]}")"
#   if [ ! -f "$(dirname "${BASH_SOURCE[0]}")/external/vsi_common/env.bsh" ]; then
#     echo "'just' could not be loaded. Trying to setup the repository as an"
#     echo "air-gapped repository"
#     # source the contents of repo_map.env (in a bash 3.2 compatible way)
#     source /dev/stdin <<< "$(git show origin/__just_git_mirror_info_file:repo_map.env 2>/dev/null || :)"
#     if ! declare -Fx git_airgap_submodule_update; then
#       echo "ERROR the vsi_common submodule could not be found
#       return 1
#     fi
#     git_airgap_submodule_update "$(dirname "${BASH_SOURCE[0]}")/external/vsi_common"
#   fi
#   source "$(dirname "${BASH_SOURCE[0]}")/external/vsi_common/env.bsh"

function print_git_airgap_submodule_update()
{
  # NOTE Do not use vsi_common functionality in this function! It is saved to
  # repo_map.env and sourced in setup.env
  uwecho 'function git_airgap_submodule_update()
          {
            local submodule_path="${1}"

            local current_setbuiltin_flags
            printf -v current_setbuiltin_flags "%s" $- # get the shell options (set builtin)
            set -eu # fail fast

            # Find submodule in the list
            for index in "${!repo_paths[@]}"; do
              [ "${repo_paths[$index]}" = "${submodule_path}" ] && break
            done
            repo_url="${repo_urls[$index]}"
            unset index repo_urls repo_paths

            # This follows just:git_mirror:git_clone_main
            git submodule init "${submodule_path}"
            git config "submodule.${submodule_path}.url" "${repo_url}"
            unset repo_url
            git submodule update "${submodule_path}"

            set +$- # unset all set flags
            set -"${current_setbuiltin_flags}"
          }
          '
}

#**
# .. function:: relocate_git_defaultify
#
# Git relocate plugin for just
#**

function relocate_git_defaultify()
{
  arg=$1
  shift 1
  case $arg in
    # Create a mirror of a git repository (which is not the same thing as a
    # clone) and all of its submodules (for a specific branch). The mirror is
    # based on the URL of a git remote in this clone---not directly on this
    # clone itself.
    #
    # REVIEW When just supports it, rename 'git export-repo --guided'
    git_export-repo-guided) # Walk through how to export a mirror of the git \
                            # repository, including all submodules, to a tarball
      if [ $# -eq 0 ]; then
        echo "Creating a mirror of a git repository (which is not the same"
        echo "thing as a clone) and all of its submodules (for a specific"
        echo "branch). The mirror is based on the URL for a git remote in this"
        echo "clone---not directly on this clone itself."
        echo
        echo "NOTE A question can be bypassed by adding the respective flag."
        echo "Add --help to see the flags."
        echo
      fi

      local check_remote
      local remote_name
      local prep_dir
      local branch
      local output_dir
      # In some versions of bash, these variables must explicitly be set to null
      unset check_remote
      unset remote_name
      unset prep_dir
      unset branch
      unset output_dir

      # REVIEW Switch to command_tools:parse_args
      # RE Doesn't support help or die on unprocessed flags/positional arguments,
      # so I'd have to have a while loop like this to deal with those anyway;
      # Also have to handle the --no- variant manually
      while (( $# )); do
        # Convert arguments of the form -f=val to -f val and --flag=val to --flag val
        # https://medium.com/@binaryphile/nice-one-elegant-in-its-simplicity-eee6b433bc90
        if [[ $1 == -?=* ]] || [[ $1 == --*=* ]]; then
          set -- "${1%%=*}" "${1#*=}" "${@:2}"
        fi
        case "$1" in
          -h|--help)
            echo "just git export-repo-guided [-b|--branch] [-c|--[no-]check-remote]"
            echo "                            [-r|--remote-name] [-p|--prep-dir]"
            echo "                            [-o|--output-dir] [-h|--help]"
            echo
            exit 1
            ;;
          # The branch from which to identify the submodules
          -b|--branch)
            branch=$2
            extra_args+=2
            shift 2
            ;;
          # Check for unpushed commits
          -c|--check-remote)
            check_remote="1"
            extra_args+=1
            shift 1
            ;;
          # Don't check for unpushed commits
          --no-check-remote)
            check_remote="0"
            extra_args+=1
            shift 1
            ;;
          # Repository's remote name (e.g., origin)
          -r|--remote-name)
            remote_name=$2
            extra_args+=2
            shift 2
            ;;
          # NOTE Supporting remote_url is somewhat hard because the remote_name
          # must be looked up somehow
          # RE Unfortunately, we may still need to ask which remote url to use
          #-u|--remote-url)
          #  ;;
          # The directory to which the repo has previously been
          # mirrored; it acts as a cache
          -p|--prep-dir)
            prep_dir=$2
            extra_args+=2
            shift 2
            ;;
          # The directory in which to mirror the repo
          -o|--output-dir)
            output_dir=$2
            extra_args+=2
            shift 2
            ;;
          -*|--*)
            echo "Unknown flag: $1"
            exit 1
            ;;
          *)
            echo "Positional arguments are not allowed: $1"
            exit 1
            ;;
        esac
      done
      # Only prep_dir xor remote_name can be set
      if [ -n "${prep_dir+x}" ] && [ -n "${remote_name+x}" ]; then
        echo "Only one of --prep-dir and --remote-name can be given"
        exit 1
      fi
      # Only prep_dir xor output_dir can be set
      if [ -n "${prep_dir+x}" ] && [ -n "${output_dir+x}" ]; then
        echo "Only one of --prep_dir and --output_dir can be given"
        exit 1
      fi


      # Unit Tests
      # no remote_name
      #   no remotes (repo initialized locally)
      #   a single named remote with no url - expect fail (misconfigured repo)
      #   a single named remote
      #   a single named remote with multiple urls
      #   a single named remote with multiple urls, one of which is a duplicate
      #   multiple named remotes
      #   multiple named remotes with multiple urls
      #   multiple named remotes with multiple urls, one of which is a duplicate
      # set remote_name
      #   a single remote url for a named remote
      #   multiple remote urls for a named remote (via git remote set-url --add)
      #   a named remote that does not exist

      local valid_remote_names=($(${GIT} remote))
      if [ "${#valid_remote_names[@]}" -eq 0 ]; then
        # REVIEW Either the repo is misconfigured or initialized locally.
        # In the latter case at least, we could mirror the repo directly
        # RE We won't worry about that use case now
        echo "This repository has no remotes. Please push the repo to a"
        echo "git server and try again."
        exit 1
      fi

      local remote_names
      unset remote_names
      # Are either remote_name or prep_dir provided as flags
      if [ -z "${remote_name+x}" ] && [ -z "${prep_dir+x}" ]; then
        echo "Would you like to:"
        picker "Create a new mirror from a remote's URL" \
               "Base off an existing airgap mirror (i.e., a PREP_DIR)" || picked=$?
        echo
        if [ "${picked}" -eq 1 ]; then
          local OLD_IFS="${IFS}"
          IFS=$'\n'
          # No quotes around subshell to create array (although IFS must be correct)
          remote_names=("${valid_remote_names[@]}")
          IFS="${OLD_IFS}"
        else
          # cd so that tab completion works
          pushd "${JUST_WORKING_DIR}" &>/dev/null
            read -r -e -p "Where is the existing mirror: " prep_dir
            echo
          popd &>/dev/null
        fi
      elif [ -n "${remote_name+x}" ]; then
        # Validate remote_name is a git remote
        if ! isin "${remote_name}" "${valid_remote_names[@]}"; then
          echo "ERROR Unknown git remote provided with flag --remote-name: ${remote_name}"
          exit 1
        fi

        remote_names=("${remote_name}")
      elif [ -n "${prep_dir+x}" ]; then
        # Because prep_dir must always be validated, whether it was provided as
        # a flag or asked for, it is validated below
        :
      fi
      # remote_names or prep_dir is set


      local remote_url
      local remote_name
      if [ -n "${remote_names+x}" ]; then
        local associated_remote_urls=()
        local associated_remote_names=()
        for remote_name in "${remote_names[@]}"; do
          local OLD_IFS="${IFS}"
          IFS=$'\n'
          # List urls configured for git fetch (i.e., the urls in the
          # .git/config:[remote] section)
          # NOTE Since git 1.8, a remote (e.g., origin) can have multiple
          # associated urls (and pushurls) (see .git/config)
          #
          # Make the list unique, preserving order
          # https://stackoverflow.com/a/31038481/1771778
          # https://stackoverflow.com/a/17562858/1771778
          #
          # No quotes around subshell to create array (although IFS must be correct)
          local remote_urls=($(${GIT} config --get-all remote."${remote_name}".url | awk '!a[$0]++'))
          associated_remote_urls+=("${remote_urls[@]}")
          local i
          for i in "${!remote_urls[@]}"; do
            associated_remote_names+=("${remote_name}")
          done
          IFS="${OLD_IFS}"
        done

        if [ "${#associated_remote_urls[@]}" -eq 0 ]; then
          # This shouldn't happen; if the repo has a named remote, it should
          # have an associated remote url
          echo "ERROR This repository is misconfigured: it has no remote urls."
          echo "Please fix!"
          exit 1
        elif [ "${#associated_remote_urls[@]}" -eq 1 ]; then
          remote_name="${associated_remote_names[0]}"
          remote_url="${associated_remote_urls[0]}"
          echo "Using remote: '${remote_name}' located at"
          echo "   ${remote_url}"
          echo
        elif [ "${#associated_remote_urls[@]}" -gt 1 ]; then
          local remote_strings=()
          local i
          for i in "${!associated_remote_urls[@]}"; do
            remote_strings+=("$(printf "%s\t%s\n" "${associated_remote_names[$i]}" "${associated_remote_urls[$i]}")")
          done

          echo "Please choose a remote:"
          local picked
          # TODO Would be nice if picker supported a default option (origin)
          picker "${remote_strings[@]}" || picked=$?
          echo
          remote_name="${associated_remote_names[picked-1]}"
          remote_url="${associated_remote_urls[picked-1]}"
        fi
      elif [ -n "${prep_dir+x}" ]; then
        # Validate this looks like a prep_dir; this is how git_mirror_main
        # computes this variable
        if [ -f "${JUST_WORKING_DIR}/${prep_dir}/"*"/config" ]; then
          pushd "$(dirname "${JUST_WORKING_DIR}/${prep_dir}/"*"/config")" &> /dev/null
            # This is the only remote that exists in the prep_dir
            remote_name="origin"
            remote_url="$(${GIT} config --get remote.origin.url)"
            # Simply treat the prep_dir as the output_dir
            # REVIEW I do this primarily because the the rest of this target
            # assumes it is operating on this repository. However, during
            # check_remote for instance, this could mean a different set of
            # push_urls from the one used to create the prep_dir is offered
            # RE I've been thinking I need to add a push-url flag; if i did
            # that, I could set push_urls here
            output_dir="${prep_dir}"
            unset prep_dir
          popd &> /dev/null
        else
          echo "ERROR ${prep_dir} does not look like a PREP_DIR"
          exit 1
        fi
      fi


      # Unit Tests
      # no branch
      #   a single branch
      #   multiple branches
      # set branch
      #   a branch that does not exist

      local valid_branches=($(${GIT} for-each-ref --format='%(refname:short)' refs/heads))
      if [ "${#valid_remote_names[@]}" -eq 0 ]; then
        # REVIEW Either the repo is misconfigured or initialized locally.
        # In the latter case at least, we could mirror the repo directly
        # RE We won't worry about that use case now
          echo "ERROR This repository is misconfigured: it has no branches."
          echo "Please fix!"
        exit 1
      fi

      local branch
      # Is branch provided as a flag
      if [ -z "${branch+x}" ]; then
        local branch
        # List local branches (branch names cannot have spaces)
        branches=("${valid_branches[@]}")
        if [ "${#branches[@]}" -eq 1 ]; then
          branch="${branches[0]}"
          echo "Using the only branch in this repository: '${branch}'"
          echo
        else
          local picked
          echo "Please choose which branch you would like to base the submodules off:"
          # TODO Would be nice if picker supported a default option (current_branch)
          picker "${branches[@]}" || picked=$?
          echo
          branch="${branches[picked-1]}"
        fi
      elif [ -n "${branch+x}" ]; then
        # Validate branch is a git branch
        if ! isin "${branch}" "${valid_branches[@]}"; then
          echo "ERROR Unknown git branch provided with flag --branch: ${branch}"
          exit 1
        fi
      fi


      # Unit Tests
      # all commits have been pushed - should succeed
      # a commit has not been pushed - should fail
      # a submodule has commits that have not been pushed - should fail
      #
      # variations:
      # a single https url in .git/config - should convert it to the git@ and
      #     offer both as pushurls
      # multiple https urls in .git/config - should convert them to the git@
      #     syntax and offer all as pushurls
      # duplicate https urls in .git/config - should convert them to the git@
      #     syntax and offer the unique list as pushurls
      # a single pushurl (https or git@) - should pick it automatically
      # multiple pushurls - should ask to pick
      # a single pushurl that is misconfigured somehow (gi@ instead of git@; it
      #   does not have the correct path component) - dry-run should fail

      # Is check_remote set by a flag
      if [ -z "${check_remote+x}" ]; then
        ask_question "Do you want to ensure all local changes have been pushed to '${remote_name}'" \
            check_remote y
        echo
      fi
      if [ "${check_remote}" == "1" ]; then
        local OLD_IFS="${IFS}"
        IFS=$'\n'
        local push_urls
        local push_urls_rv=0
        # List urls configured for git push (i.e., the pushurls, if configured,
        # in the .git/config:[remote] section)
        # NOTE since git 1.8, a remote (e.g., origin) can have multiple
        # associated pushurls
        # No quotes around subshell to create array (although IFS must be correct)
        push_urls=($(${GIT} config --get-all remote."${remote_name}".pushurl)) || push_urls_rv=$?
        # If no pushurl is configured, get the urls (which would be used as the
        # pushurls)
        if [ "${push_urls_rv}" -ne 0 ]; then
          # No quotes around subshell to create array (although IFS must be correct)
          push_urls=($(${GIT} config --get-all remote."${remote_name}".url))

          local push_url
          local git_push_url
          local to_add=()
          # Try converting these to the git@ syntax and offering them as
          # additional options in the set of pushurls
          for push_url in "${push_urls[@]}"; do
            local git_push_url_rv=0
            git_push_url="$(trap -- ERR; _https_to_git_protocol "${push_url}")" || git_push_url_rv=$?
            if [ "${git_push_url_rv}" -eq 0 ]; then
              to_add+=("${git_push_url}")
            fi
          done
          push_urls+=(${to_add+"${to_add[@]}"})
        fi
        # Make the list unique, preserving order
        # https://stackoverflow.com/a/31038481/1771778
        # https://stackoverflow.com/a/17562858/1771778
        push_urls=($(printf "%s\n" "${push_urls[@]}" | awk '!a[$0]++'))
        IFS="${OLD_IFS}"

        local push_url
        # Either a single url (which cannot be converted to the git@ syntax) or
        # a single pushurl is configured
        if [ "${#push_urls[@]}" -eq 1 ]; then
          push_url="${push_urls[0]}"
        # Not only is a pushurl configured, but there are multiple of them
        # (which is prob rare)
        else
          # REVIEW no flag to set this var; add a --force flag to select the
          # first pushurl
          local picked
          echo "Please choose which remote (push) url you would like to use:"
          picker "${push_urls[@]}" || picked=$?
          echo
          push_url="${push_urls[picked-1]}"
        fi

        # Connecting to the URL is required when creating the mirror, so this
        # is ok
        local dryrun_test_rv=0
        local dryrun_test
        # FIXME This does not check sub-submodules. If the submodule, but not
        # one of its submodules, has been pushed to the remote, it passes
        # local foo="$(bar)" || rv=$? does not work as one line in bash 4.2 or older. Ues two lines
        dryrun_test="$(${GIT} push --dry-run --recurse-submodules=check "${push_url}" "${branch}" 2>&1)" || \
            dryrun_test_rv=$?
        if [ "${dryrun_test_rv}" != "0" ]; then
          echo "${dryrun_test}"
          exit 1
        fi
        if [ "${dryrun_test}" == "Everything up-to-date" ]; then
          echo "Everything up-to-date"
          echo
        else
          # REVIEW unpushed commits in the top-level repo can be ignored, but a
          # submodule with changes that have not been pushed, which are being
          # tracked by this branch, probably should not be
          echo "${dryrun_test}"
          echo
          echo "WARNING there are unpushed changes on branch, '${branch}'. You may"
          echo "want to ensure all changes to this repository and its submodules"
          echo "have been pushed to the remote server."
          ask_question "Continue?" response n
          [ "$response" == "0" ] && exit 1
        fi
      fi


      # Is output_dir unset; i.e., it was not set either as a flag or inferred
      # from prep_dir
      if [ -z "${output_dir+x}" ]; then
        # cd so that tab completion works
        pushd "${JUST_WORKING_DIR}" &>/dev/null
          # REVIEW After all this, the user could choose an output_dir which is
          # a prep_dir
          # RE I guess that would be ok though
          echo "Where would you like the mirror to be created"
          read -r -e -p \
              "Note: keep this directory as a cache and reuse it during future mirrors: " \
              output_dir
          echo
        popd &>/dev/null
      fi

      justify git_export-repo "${remote_url}" "${branch}" "${output_dir}"
      ;;

    # REVIEW Rename to git_mirror-repo and git_push-airgap-repo
    # NOTE this is tightly coupled with git_import-repo
    git_export-repo) # Export a mirror of the git repository, including all \
                     # submodules, to a tarball
      # REVIEW Move this functionality into a function

      # ASSUMPTION We are currently in the project's root directory; this is
      # normally the case with just

      # just cd's into the project's root directory, which will make
      # prep_dir/output_dir relative to that, not the user's CWD
      pushd "${JUST_WORKING_DIR}" &>/dev/null
        # Sets GIT_MIRROR_PREP_DIR and GIT_MIRROR_MAIN_REPO
        git_mirror_repos ${@+"${@}"}
      popd &>/dev/null

      # Find the name of the top-level repo according to the remote url
      # This is how git_mirror_main computes this variable
      local repo_name="$(basename "${GIT_MIRROR_MAIN_REPO}")"
      repo_name="${repo_name%.*}"

      # Create the file that maps between the submodule's path and its new URL.
      # This mapping MUST be created in this repo because the mirror in the
      # prep_dir does not have its submodules recursively updated
      create_repo_map "${repo_name}" > "${GIT_MIRROR_PREP_DIR}/repo_map.env"

      # Copy a simple Justfile to make import-repo easy
      add_import-repo_just_project "${GIT_MIRROR_PREP_DIR}"

      # Archive the mirrored repos
      archive_mirrors "${GIT_MIRROR_PREP_DIR}"

      extra_args=$#
      ;;

    git_import-repo) # Push a repo exported with `git export-repo` to an \
                     # initialized git repo
      # REVIEW Move this functionality into a function

      # ASSUMPTION The bare repos for the submodules have been initialized
      # ASSUMPTION We are using the simple just project setup by
      # add_import-repo_just_project in git_export-repo, and are therefore
      # currently in the PREP_DIR

      # This is how git_push_main computes this variable
      local main_dir="$(dirname "$(ls */config)")"

      source repo_map.env # Sets repo_paths and repo_urls
      # Now that the env variables used by repo_urls in repo_map.env have been
      # expanded, resave the file
      # REVIEW run urls through _https_to_git_protocol
      print_repo_map > repo_map.env
      print_git_airgap_submodule_update >> repo_map.env
      repo_map="$(cat repo_map.env)"

      # Now that the repo_urls have been expanded, update the repo_map.env file
      # in the orphan branch so that they are correct going forward; e.g., during
      # git_clone-airgap-repo
      pushd "${main_dir}" &>/dev/null
        orphan_commit_repo_map "${repo_map}"
      popd &>/dev/null

      git_push_main repo_map.env ./
      ;;

    git_clone-airgap-repo) # Clone a repo exported with `git export-repo`. This \
                           # is necessary because we do not want to update the \
                           # url's of the submodules
      # NOTE setup.env must be edited to include logic to init and update
      # vsi_common (basically copying part of git_clone_main) before this
      # target can be called

      local repo_map_file
      make_temp_path repo_map_file # auto-deleting file
      # The repo map's submodule URLs were corrected in git_import-repo
      git show origin/__just_git_mirror_info_file:repo_map.env > "${repo_map_file}"
      git_clone_main "${repo_map_file}" ./
      ;;

    # TODO Generalize to support log_outgoing_commits too
    # TODO Support filtering by branches/remotes
    # TODO Move to just_git_functions
    git_unpushed-commits) # List unpushed commits on a branch
      if ! command -v ${GIT} >& /dev/null; then
        echo "Git not found, skipping listing of unpushed commits" >&2
        return 0
      fi

      local commits="$(log_unpushed_commits)"
      if [ "${commits}" != "" ]; then
        local ncommits="$(echo "${commits}" | grep -o '^\* commit' | wc -l | tr -d '[:space:]')"
        if [ "${ncommits}" -eq 0 ]; then
          : # pass
        elif [ "${ncommits}" -eq 1 ]; then
          echo "There is ${ncommits} unpushed commit:"
          echo
        elif [ "${ncommits}" -gt 1 ]; then
          echo "There are ${ncommits} unpushed commits:"
          echo
        fi
        echo "${commits}"
      fi
      ;;

    # TODO Move to just_git_functions
    git_make-remote-urls-pushable) # Change the remote urls to use the git@ \
                                   # syntax instead of https
      if ! command -v ${GIT} >& /dev/null; then
        echo "Git not found, skipping remote url conversion" >&2
        return 0
      fi

      # TODO Support iterating through all submodules
      make_remote_urls_pushable
      ;;

    *)
      plugin_not_found=1
      ;;
  esac
  return 0
}
