#!/usr/bin/env false bash

if [[ $- != *i* ]]; then
  source_once &> /dev/null && return 0
fi

JUST_DEFAULTIFY_FUNCTIONS+=(relocate_git_defaultify)
JUST_HELP_FILES+=("${BASH_SOURCE[0]}")

#*# just/plugins/just_git_airgap_repo

#**
# .. default-domain:: bash
#
# ===============================================
# J.U.S.T. Git Mirror to an Air-gapped Repository
# ===============================================
#
# .. file:: just_git_airgap_repo.bsh
#
# While creating a git mirror is as simple as ``git clone --mirror``, unfortunately this git command does not support git submodules or lfs. These functions help in creating and subsequently cloning a mirror of a project with submodules and/or git lfs.
#
# .. rubric:: Example
#
# Example usage:
#
# 1. ``just git export-repo https://github.com/visionsystemsinc/vsi_common.git master ~/`` - Mirror the repository and recursively create mirrors of all submodules currently in the master branch.
# 2. Transfer ``vsi_common_prep/transfer_{date}.tgz`` to your destination.
# 3. Initialize bare repositories on the git server for vsi_common and its submodule, recipes. Note: vsi_common_prep/repo_map.env contains the list of the submodules in a project and their expected server paths. By default these are specified with the environment variables :envvar:`JUST_GIT_AIRGAP_SERVER` and :envvar:`JUST_GIT_AIRGAP_ORGANIZATION`:
#   - https://${JUST_GIT_AIRGAP_SERVER}/${JUST_GIT_AIRGAP_ORGANIZATION}/vsi_common.git
#   - https://${JUST_GIT_AIRGAP_SERVER}/${JUST_GIT_AIRGAP_ORGANIZATION}/recipes.git
# 4. Extract the archive
#   a) In vsi_common_prep, edit mirror.env and set
#     - JUST_GIT_AIRGAP_SERVER=https://git-server.com/
#     - JUST_GIT_AIRGAP_ORGANIZATION=org
#    ALTERNATIVELY the Justfile could ask for these things
# 5. ``source setup.env``
# 6. ``just git import-repo`` - Push the mirrored repository and all submodules to a new git server as defined by info.env
#
# A developer can then run:
# 1. ``git clone https://git-server.com/visionsystemsinc/vsi_common.git``
# 2. ``just git clone-airgap-repo`` - Clone submodules recursively from the new mirror
#**

source "${VSI_COMMON_DIR}/linux/ask_question"
source "${VSI_COMMON_DIR}/linux/git_mirror"
source "${VSI_COMMON_DIR}/linux/uwecho.bsh"

#**
# .. envvar:: GIT
#
# Name/path of git executable
#
# Instead of hard-coding "git" everywhere, use the variable :envvar:`GIT` so that when the need comes, it is easier to switch which executable gets called. Set to empty string to have any calls to git skipped.
#
# All :func:`relocate_git_defaultify` targets will be skipped if the value of :envvar:`GIT` is not found or empty.
#
# .. note::
#   When using the GIT env variable in this file, do not surround it with quotes as you normally would. Although this prevents using a path to ``git`` with a space in it, in exchange, it may be possible (eventually) to enable a dry-run-ish capability if GIT is set to 'echo git'.
#**

: ${GIT=git}


# unit tests:
# NOTE a tracking branch must actually be setup
# nothing unpushed - branch (non-tracking) behind origin/master
# nothing unpushed - branch (non-tracking) equal to origin/master
# unpushed commits - branch (non-tracking) ahead of origin/master
# no outgoing commits - tracking_branch is behind its tracked origin/tracking_branch
# no outgoing commits - tracking_branch is behind its tracked origin/master
# no outgoing commits - tracking_branch is equal to its tracked origin/tracking_branch
# outgoing commits - tracking_branch is ahead of its tracked origin/tracking_branch
# outgoing commits - tracking_branch is ahead of its tracked origin/master
# ignore outgoing commits - remote-tracking branch removed, but the local-tracking branch remains
# ignore outgoing commits - no tracking branches


#**
# .. function:: log_unpushed_commits
#
# List all unpushed commits to stdout
#
# List all commits on branches that have not been pushed to a remote. This is a set operation: it lists all the commits from a branch in the DAG except those reachable by a remote-tracking branch. It does not require an *associated* remote-tracking branch
#
# REVIEW what order should these go in
# :Arguments: - ``1`` - A branch's name to filter by; e.g., master. If unset, then don't filter
#             - ``2`` - A name of a remote to filter by; e.g., origin. If unset, then don't filter
#
# :Output: - ``*stdout*`` - Print all unpushed commits for tracking branches to stdout
#**

function log_unpushed_commits()
{
  # NOTE Only supports passing in a single branch and remote name
  local branch="${1---branches}"
  local remote_name="${2-}"

  local commits="$(${GIT} log --decorate --graph --format=short --color=always \
      "${branch}" --not --remotes="${remote_name}")"
  echo "${commits}"
}

#**
# .. function:: git_tracking_branches
#
# Find remote- and corresponding local-tracking branches
#
# :Arguments: - ``1`` - A name of a remote to filter by; e.g., origin. If unset, then don't filter
#
# :Output: - ``just_git_tracking_branches`` - An array of local-tracking branch names
#          - ``just_git_remote_tracking_branches`` - A corresponding array of remote-tracking branch names
#
# .. note::
#    - A branch that you create locally and then push to a remote is not configured as a local-tracking branch by default. You must use the -u flag with 'git push' or 'git branch'.
#   - A branch cannot track multiple remotes.
#   - Requires git >= 1.9.0
#**

function git_tracking_branches()
{
  # REVIEW could support multiple remote names with a for loop
  local remote_name="${1-}"

  local OLD_IFS="${IFS}"
  IFS=$'\n'
  # E.g., upstream:short=origin/master, refname=refs/heads/master and
  # upstream:track=[gone] if the remote-tracking branch has been pruned
  # NOTE %(upstream:track) requires git >= 1.9.0
  # NOTE No quotes around subshell to create array
  local tracking_branches=($( \
      ${GIT} for-each-ref --format='%(upstream:short) %(refname) %(upstream:track)' refs/heads | \
      # Discard lines in which upstream is unset, i.e., those with a leading space
      # RE this seems brittle
      # Also trim whitespace at the end of each line
      # TODO switch to string_tools.bsh:rtrim
      grep -v '^ ' | grep -v '\[gone\]$' | grep "^${remote_name}" | sed 's/[[:space:]]+$//' || :))
  IFS="${OLD_IFS}"
  #
  # Similarly: git rev-parse --abbrev-ref branch@{upstream} will also give the
  # tracking branch (or error if one doesn't exist or has been pruned). This
  # can be combined with git for-each-ref --format='%(refname:short)' refs/heads
  # which lists all local branches.
  # Alternatively: git branch -vv provides the same tracking information as
  # upstream:track, even in git 1.8.3
  # RE this is the only command to get this info in git 1.8.3; although it can
  # be calculated manually with git log --format='%H' branch@{upstream}..branch
  # for outgoing commits and git log --format='%H' branch..branch@{upstream}
  # for incoming
  # RE git rev-list --left-right --boundary branch@{upstream}...branch lists
  # both incoming and outgoing changes as well (the symmetric difference)
  # git remote show origin actually queries the remote; however, it doesn't
  # provide the same level of tracking detail

  just_git_tracking_branches=()
  just_git_remote_tracking_branches=()
  for tracking_branch in ${tracking_branches+"${tracking_branches[@]}"}; do
    local branch="$(echo "${tracking_branch}" | awk '{print $2}')"
    # Strip refs/heads prefix from the remoteref
    just_git_tracking_branches+=("${branch/refs\/heads\//}")
    just_git_remote_tracking_branches+=("$(echo "${tracking_branch}" | awk '{print $1}')")
  done
}

#**
# .. function:: log_outgoing_commits
#
# List all unpushed commits for a tracking branches to stdout
#
# REVIEW what order should these go in
# :Arguments: - ``1`` - A local-tracking branch's name to filter by; e.g., master. If unset, then don't filter by branch name
#             - ``2`` - A name of a remote to filter by; e.g., origin. If unset, then don't filter
#
# :Output: - ``*stdout*`` - Print all unpushed commits for tracking branches to stdout
#
# .. note:: A branch cannot track multiple remotes.
#**

function log_outgoing_commits()
{
  # NOTE Only supports passing in a single branch and remote name
  local remote_name="${2-}"

  local tracking_branches
  if [ $# -eq 0 ]; then
    git_tracking_branches "${remote_name}" # Sets just_git_tracking_branches
    tracking_branches=("${just_git_tracking_branches[@]}")
  else
    tracking_branches=("${1}")
  fi

  # This will list only the outgoing commits for a local-tracking branch
  local tracking_branch
  local commits=()
  for tracking_branch in "${tracking_branches[@]}"; do
    commits+=("$(${GIT} log --decorate --graph --format=short --color=always \
        "${tracking_branch}"@{upstream}.."${tracking_branch}")")
  done
  local OLD_IFS="${IFS}"
  IFS=$'\n'
  echo "${commits[*]}"
  IFS="${OLD_IFS}"
}

#**
# .. function:: submodule_summary
#
# Compare the expected commit of each submodule to its current working tree
#
# Using ``git diff --submodule=log``, compare the working tree of each submodule to the version commited to HEAD of the super project, and list any commits that are missing and/or now present in the submodule. For example, if an earlier commit in the submodule is checked out, there will be missing commits in the submodule according to the super project. Similarly, if a commit is made to the submodule, there will be new commits present in the submodule according to the super project. Of course, the commit graph could diverge in more complicated ways.
#
# :Output: - ``*stdout*`` - Each submodule's differences in terms of commits
#
# .. seealso:: https://git-scm.com/docs/git-diff#Documentation/git-diff.txt---submoduleltformatgt
#
# TODO support iterating through all submodules
#**

function submodule_summary()
{
  local OLD_IFS="${IFS}"
  IFS=$'\n'
  for x in $("${GIT}" config --name-only --file .gitmodules --get-regexp '^submodule\..*\.path$'); do
    "${GIT}" diff --submodule=log "$("${GIT}" config --file .gitmodules --get "${x}")"
  done
  IFS="${OLD_IFS}"
}

# 'git push --recurse-submodules=check' (available in git 1.8.0) will check for unpushed commits in a submodule for its current committed state in the parent project
# RE 'git config push.recurseSubmodules check' (available in git 2.7.0)

#**
# .. function:: make_remote_urls_pushable
#
# Change the remote url of a git repo to use the git@ syntax instead of https
#
# Query the git repository's remotes; if the URL of the remote is specified using the the https:// protocol, convert it to the ssh transfer protocol (git@..) to make pushing changes to the remote server easier. Assume a very basic url format: https://git-server.com/co/project.git without port, query, or fragment sections. Warn if these exist
#
# :Arguments: - ``1`` - A name of a remote to filter by; e.g., origin. If unset, then don't filter
#
# .. note::
#  This does not change the submodule's tracked URL, i.e., the URL in the .gitmodules file, only the url in .git/config
#**

function make_remote_urls_pushable()
{
  local specified_remote_name="${1-}"

  local remote
  ${GIT} remote -v | grep '(push)$' | while read remote;
  do
    local remote_name
    local remote_url
    read -r remote_name remote_url <<< "$(echo "${remote}" | awk '{print $1 " " $2}')"
    if [ -n "${specified_remote_name}" ] && \
       [ "${specified_remote_name}" != "${remote_name}" ]; then
      continue
    fi

    local remote_git_url_rv=0
    local remote_git_url
    # local foo="$(bar)" || rv=$? does not work as one line in bash 4.2 or older. Ues two lines
    remote_git_url="$(_https_to_git_protocol "${remote_url}")" || remote_git_url_rv=$?
    if [ "${remote_git_url_rv}" == "0" ]; then
      ${GIT} remote set-url "${remote_name}" --push "${remote_git_url}"
    else # See if URL is already in the expected format
      # This is very simple; basically undo the simple transform done here.
      # Perhaps one day we will have a git remote url parser in parser.bsh
      local remote_https_url="$(echo "${remote_url}" | sed -e 's#^git@#https://#' -e 's#:#/#3')"
      if ! parse_url "${remote_https_url}"; then
        echo "WARNING URL is non-standard. Skipping ${remote_url}"
      fi
    fi
  done
}

function _https_to_git_protocol()
{
  local remote_url="${1}"

  # Be very conservative about which URLs will convert
  # NOTE If the git server has a non-standard port (which would not be the
  # same as https port), you have to do ssh://git@server:port/...
  if parse_url "${remote_url}"; then # Sets just_url_parsed_host, just_url_parsed_rpath, etc.
    if [ "${just_url_parsed_port}" != "" ] || \
       [ "${just_url_parsed_query}" != "" ] || \
       [ "${just_url_parsed_fragment}" != "" ]; then
      echo "${remote_url}"
      return 1
    elif [ "${just_url_parsed_scheme}" == "http" ] || \
         [ "${just_url_parsed_scheme}" == "https" ]; then
      local remote_git_url="git@${just_url_parsed_host}:${just_url_parsed_rpath}"
      echo "${remote_git_url}"
    fi
  else
    echo "${remote_url}"
    return 1
  fi
}

# Similar to git rev-parse --show-toplevel
function toplevel()
{
   realpath "$(${GIT} rev-parse --git-dir)" | awk -F '/.git' '{print $1}'
}

# Get the (relative) path from the top-level repository to the submodule
#
# NOTE The submodules must have been checked out recursively (which is obviously
# not the case in a bare/mirror repo)
function submodule_paths()
{
  # At some point, prefix was deprecated and removed in favor of displaypath
  # NOTE prefix/displaypath only provides the expected path if this command is
  # run from the root of the top-level repository. Fortunately, that is the case
  # in the Justfile.
  # Alternatively, add JUST_PROJECT_DIR to just or use :func:`toplevel`
  ${GIT} submodule foreach --quiet --recursive 'echo ${prefix-${displaypath}}'
}

# Get all submodule urls
# NOTE The submodules must have been checked out recursively (which is obviously
# not the case in a bare/mirror repo)
function submodule_urls()
{
  # REVIEW should i unset GIT_DIR?
  ${GIT} submodule foreach --quiet --recursive \
      "export GIT; bash -euc 'echo \"\$(${GIT} config --get remote.origin.url)\"'"
}

# Create a URL with env variables that will expand to the mirrored repo's new
# location on the airgapped git server of the form:
# repo_paths=(
#   ./
#   ./docker/recipes
# )
# repo_urls=(
#   '${JUST_GIT_AIRGAP_SERVER}/${JUST_GIT_AIRGAP_ORGANIZATION}'/vsi_common.git
#   '${JUST_GIT_AIRGAP_SERVER}/${JUST_GIT_AIRGAP_ORGANIZATION}'/recipes.git
# )
# which could, for example, expand to https://git-server/org/vsi_common.git and
# https://git-server/org/recipes.git
#
# NOTE that this function could be overridden by the user
function create_repo_map()
{
  local OLD_IFS="${IFS}"
  IFS=$'\n'
  # No quotes around subshell to create array (although IFS must be correct)
  local repo_paths=($(submodule_paths))
  IFS="${OLD_IFS}"

  local repo_urls=()
  local repo_path
  for repo_path in "${repo_paths[@]}"; do
    # NOTE Quotes around JUST_AIRGAP_GIT_SERVER aren't necessary here because
    # the entries will be quoted when printed to file
    repo_urls+=('${JUST_GIT_AIRGAP_SERVER}/${JUST_GIT_AIRGAP_ORGANIZATION}'/$(basename "${repo_path}"))
  done

  printf '# NOTE: This file is automatically created by `create_repo_map`.\n'
  printf '#'
  printf '# If this mapping between submodules and URLs does not suit your\n'
  printf '# needs, you can edit it directly or override `create_repo_map`\n'
  printf '# before calling `just git export-repo`'
  printf '\n\n'
  printf 'repo_paths=(\n'
  printf '  "%s"\n' "${repo_paths[@]}"
  printf ')\n\n'
  printf 'repo_urls=(\n'
  printf '  "%s"\n' "${repo_urls[@]}"
  printf ')\n'
}

# Given a repo_map like the one produced by :func:`create_repo_map`, make an
# orphan commit in the repo (on a branch named __just_git_mirror_info_file by
# default) to a file named repo_map.env. An intermediate product of this
# function is a shallow clone of the current repo to a directory called
# __just_git_clone, which is removed at the end of the function
function orphan_commit_repo_map
{
  repo_map="${1}"
  orphan_branch="${2-__just_git_mirror_info_file}"

  # Clone (non-recursively) the repo in which to make the orphan commit.
  # Avoids possibly needing to run 'git reset --hard' after checking out the
  # orphan branch and then 'git checkout' after committing to it.
  # NOTE Uses hard-links on linux
  # TODO clone into an automatically deleting temporary directory; requires
  # mktemp_compat from dir_tools.bsh
  # RE this temp dir does not auto-delete
  if ls -A __just_git_clone &>/dev/null; then
    echo "The temporary directory, ./__just_git_clone, already exists and is"
    echo "not empty. This script will delete it and continue."
    ask_question "Is that ok?" answer_delete n
    [ "$answer_delete" == "0" ] && return 1
    rm -rf __just_git_clone
  fi
  "${GIT}" clone --no-checkout ./ __just_git_clone
  pushd __just_git_clone &>/dev/null
    # Avoids checking out the files in the previously checked-out branch
    # and staging them for deletion when switching to a new (orphan) branch,
    # which then requires running 'git reset --hard' and/or 'git rm -rf .'
    # REVIEW I can't find a better way to do this
    rm .git/refs/heads/*
    "${GIT}" checkout "${orphan_branch}" 2>/dev/null || \
        "${GIT}" checkout --orphan "${orphan_branch}"

    echo "${repo_map}" > repo_map.env

    ${GIT} add repo_map.env && git commit --allow-empty --author "just git_export-repo <just@export-repo.git>" \
        -m "the repo_map.env file needed by just:git_mirror that maps repo_paths to urls"
    ${GIT} push --force origin "${orphan_branch}"
  popd &>/dev/null
  rm -rf __just_git_clone
  #
  # ALTERNATIVELY
  #current_branch="$(git rev-parse --abbrev-ref HEAD)"
  #"${GIT}" checkout "${orphan_branch}" 2>/dev/null || \
  #     "${GIT}" checkout --orphan "${orphan_branch}"
  #git reset --hard # This is important if "${orphan_branch}" was just created
  #
  #echo "${repo_map}" > repo_map.env
  #
  #"${GIT}" checkout "${current_branch}" # This could be expensive
}

# Creates a simple Justfile, setup.env, and airgap.env in the prep_dir
function add_import-repo_just_project()
{
  prep_dir="$(realpath "${1}")"

  # git archive external/vsi_common to ${prep_dir}/.vsi_common; does not include
  # submodules, but that that's ok
  pushd external/vsi_common &>/dev/null
    git archive --format=tar --prefix=.vsi_common/ HEAD | (cd "${prep_dir}" && tar xf -)
  popd &>/dev/null

  # REVIEW it might be nicer not to import a plugin here so that there is only
  # one target in just help
  uwecho '#!/usr/bin/env bash

          source "${VSI_COMMON_DIR}/linux/just_env" "$(dirname "${BASH_SOURCE[0]}")"/'airgap.env'

          source "${VSI_COMMON_DIR}/linux/just_git_airgap_repo.bsh"

          cd "${AIRGAP_MIRROR_CWD}"
          function caseify()
          {
            local just_arg=$1
            shift 1

            case ${just_arg} in
              git_push-to-mirrors) # Push the mirrored repos to new (initialized) locations
                justify git import-repo
                ;;
              *)
                defaultify "${just_arg}" ${@+"${@}"}
                ;;
            esac
          }
          ' >> "${prep_dir}"/Justfile
  # REVIEW if someone overrides create_repo_map, these env vars might not need
  # to be set
  # RE that's ok. if they are needed in repo_map.env and unset, then the script
  # will die if set -eu is enabled (which should be in just)
  # RE although the error makes it very clear how to fix it the problem
  # REVIEW if unset, ask in the Justfile
  # RE can't ask in the Justfile without disabling set -u
  uwecho 'JUST_PROJECT_PREFIX=AIRGAP_MIRROR
          JUST_VERSION="0.2.2+1dev"
          if [ -z "${AIRGAP_MIRROR_CWD+set}" ]; then
            AIRGAP_MIRROR_CWD="$(\cd "$(\dirname "${BASH_SOURCE[0]}")"; \pwd)"
          fi

          ### YOU MUST SET THESE VARIABLES ###
          JUST_GIT_AIRGAP_SERVER=
          JUST_GIT_AIRGAP_ORGANIZATION=
          ' >> "${prep_dir}"/airgap.env
  uwecho 'export JUST_SETUP_SCRIPT="$(basename "${BASH_SOURCE[0]}")"
          source "$(dirname "${BASH_SOURCE[0]}")/"'.vsi_common/env.bsh'
          unset JUSTFILE
          ' >> "${prep_dir}"/setup.env
}

#**
# .. function:: relocate_git_defaultify
#
# Git relocate plugin for just
#**

function relocate_git_defaultify()
{
  arg=$1
  shift 1
  case $arg in
    # REVIEW When just supports it, rename 'git export-repo --guided'
    git_export-repo-guided) # Walk through how to export a mirror of the git \
                            # repository, including all submodules, to a tarball
      local remote_url
      local prep_dir
      local branch
      local output_dir

      # TODO Switch to command_tools:parse_args
      while (( $# )); do
        # Convert arguments of the form -f=val to -f val and --flag=val to --flag val
        # https://medium.com/@binaryphile/nice-one-elegant-in-its-simplicity-eee6b433bc90
        if [[ $1 == -?=* ]] || [[ $1 == --*=* ]]; then
          set -- "${1%%=*}" "${1#*=}" "${@:2}"
        fi
        case $1 in
          -r|--remote-url) # Repository's remote URL
            remote_url=$2
            shift 2
            ;;
          -p|--prep-dir) # The directory to which the repo has previously been \
                         # mirrored; it acts as a cache
            prep_dir=$2
            shift 2
            ;;
          -o|--output-dir) # The directory in which to mirror the repo
            output_dir=$2
            shift 2
            ;;
          -b|--branch) # The branch from which to identify the submodules
            branch=$2
            shift 2
            ;;
          -h|--help)
            # FIXME add usage
            usage
            exit 1
            ;;
          *)
            echo "Positional arguments are not allowed: $arg"
            exit 1
            ;;
        esac
      done
      # Only prep_dir xor remote_url can be set
      if [ -n "${prep_dir}" ] && [ -n "${remote_url}" ]; then
        echo "Only one of --prep_dir and --remote-url can be given"
        exit 1
      fi
      # Only prep_dir xor output_dir can be set
      if [ -n "${prep_dir}" ] && [ -n "${output_dir}" ]; then
        echo "Only one of --prep_dir and --output_dir can be given"
        exit 1
      fi


      if [ -z "${remote_url}" ] && [ -z "${prep_dir}" ]; then
        echo "Would you like to:"
        picker "Create a new mirror" \
               "Base off an existing mirror (i.e., a PREP_DIR)" || picked=$?
        echo
        if [ "${picked}" -eq 1 ]; then
          local OLD_IFS="${IFS}"
          IFS=$'\n'
          # No quotes around subshell to create array (although IFS must be correct)
          local remotes=($(git remote -v | grep '(fetch)$' | awk '{print $1 " " $2}'))
          IFS="${OLD_IFS}"

          local remote_name
          local remote_url
          if [ "${#remotes[@]}" -eq 0 ]; then
            # This is not strictly a requirement for a simple repo that only you
            # work on locally, however we won't worry about that use case now
            echo "This repository has no remotes. Please push the repo to a"
            echo "git server and try again."
            exit 1
          elif [ "${#remotes[@]}" -eq 1 ]; then
            remote_name="$(echo "${remotes[0]}" | awk '{print $1}')"
            remote_url="$(echo "${remotes[0]}" | awk '{print $2}')"
            echo "This repository has only one remote, '${remote_name}', located at"
            echo "   ${remote_url}"
            echo
          elif [ "${#remotes[@]}" -gt 1 ]; then
            echo "Please choose a remote:"
            local picked
            # TODO would be nice if picker supported a default option (origin)
            picker "${remotes[@]}" || picked=$?
            remote_name="$(echo "${remotes[picked-1]}" | awk '{print $1}')"
            remote_url="$(echo "${remotes[picked-1]}" | awk '{print $2}')"
          fi
        else
          read -r -e -p "Where is the existing mirror: " prep_dir
          echo
        fi
      fi

      if [ -z "${branch}" ]; then
        # List local branches
        local branches=($("${GIT}" for-each-ref --format='%(refname:short)' refs/heads))
        if [ "${#branches[@]}" -eq 1 ]; then
          branch="${branches[0]}"
          echo "Using the only branch in this repository: '${branch}'"
          echo
        else
          local picked
          echo "Please choose which branch you would like to base the submodules off"
          # TODO would be nice if picker supported a default option (current_branch)
          picker "${branches[@]}" || picked=$?
          local branch="${branches[picked-1]}"
        fi
      fi

      ask_question "Do you want to ensure all local changes have been pushed to '${remote_name}'" \
          dryrun_response y
      if [ "${dryrun_response}" == "1" ]; then
        # Connecting to the URL is required when creating the mirror, so this is ok
        push_url="$(${GIT} remote get-url --push "${remote_name}")"
        push_url="$(_https_to_git_protocol "${push_url}" || :)"
        if [ "$(${GIT} push --dry-run --recurse-submodules=check "${push_url}" "${branch}" 2>&1)" != \
            "Everything up-to-date" ]; then
          echo
          echo "WARNING there are unpushed changes on branch, '${branch}'. You may"
          echo "want to ensure all changes have been pushed to the remote server."
          ask_question "Continue?" response n
          [ "$response" == "0" ] && unset response && return 1
        fi
      fi

      if [ -z "${prep_dir}" ] && [ -z "${output_dir}" ]; then
        read -r -e -p "Where would you like the mirror to be created: " output_dir
        echo
      fi

      # Good lord
      # RE with an array squasher, this could be refactored to two conditions
      if [ -n "${prep_dir}" ] && [ -n "${branch}" ]; then
        justify git_export-repo "${prep_dir}" "${branch}"
      elif [ -n "${prep_dir}" ]; then
        justify git_export-repo "${prep_dir}"
      elif [ -n "${remote_url}" ] && [ -n "${branch}" ] && [ -n "${output_dir}" ]; then
        justify git_export-repo "${remote_url}" "${branch}" "${output_dir}"
      elif [ -n "${remote_url}" ] && [ -n "${branch}" ]; then
        justify git_export-repo "${remote_url}" "${branch}"
      elif [ -n "${remote_url}" ]; then
        justify git_export-repo "${remote_url}"
      fi
      ;;

    # REVIEW rename git_mirror-repo and git_push-airgap-repo
    git_export-repo) # Export a mirror of the git repository, including all \
                     # submodules, to a tarball
      # REVIEW move this functionality into a function

      # Sets GIT_MIRROR_PREP_DIR and GIT_MIRROR_MAIN_REPO
      git_mirror_repos ${@+"${@}"}

      # This is how git_push_main computes this variable
      local main_dir="$(dirname "$(cd "${GIT_MIRROR_PREP_DIR}" && ls */config)")"

      # Create the file that maps between the submodule's path and its new URL.
      # This mapping MUST be created in the current repo because neither the
      # mirror in the prep_dir nor the clone created from it (__just_git_clone)
      # are recursively updated
      repo_map="$(create_repo_map)"

      # This is more important for clone-airgap-repo than import-repo
      pushd "${GIT_MIRROR_PREP_DIR}/${main_dir}" &>/dev/null
        # Clone the mirrored repo in the prep_dir and push to it instead of
        # the actual repo to avoid adding the orphan commit to it
        # REVIEW set the orphan branch name as an env var
        orphan_commit_repo_map "${repo_map}"

        # We are in a mirror (bare) repo here
        # REVIEW this could be moved to git_import-repo
        # RE although it too would have to know the name of the branch:file
        # RE perhaps that is ok. it makes sense that the git_import-repo would be
        # tightly coupled with the git_export-repo
        # RE saving it here also allows the user to edit it, if needed...
        git show __just_git_mirror_info_file:repo_map.env > ../repo_map.env
        # Just in case...
        cp ../repo_map.env ../repo_map.env.bak
      popd &>/dev/null

      # Copy a simple Justfile to make import-repo easy
      add_import-repo_just_project "${GIT_MIRROR_PREP_DIR}"

      # Archive the mirrored repos
      archive_mirrors "${GIT_MIRROR_PREP_DIR}"

      extra_args=$#
      ;;

    git_import-repo) # Push a repo exported with `git export-repo` to an \
                     # initialized git repo
      # REVIEW move this functionality into a function

      # Assume we are using the simple just project setup by
      # add_import-repo_just_project in git_export-repo, and are therefore
      # currently in the PREP_DIR

      # Find the main_dir
      local main_dir="$(dirname "$(ls */config)")"

      # FIXME this should error if there are unbound variables; once that's
      # fixed, test for the error and print a message saying to set the var
      # in either local.env or the airgap.env file
      source repo_map.env # Sets repo_paths and repo_urls
      # Now that the env variables used by repo_urls in repo_map.env have been
      # expanded, resave the file so that users don't have to set those env
      # variables during git_clone-airgap-repo.
      # We could write out this file in the same way that create_repo_map does,
      # but this is easier; and this file should no longer need to be inspected
      # by a human
      declare -p repo_urls > repo_map.env
      declare -p repo_paths >> repo_map.env
      repo_map="$(cat repo_map.env)"

      # Now that the repo_urls have been expanded, update the repo_map.env file
      # in the orphan branch so that they are correct going forward; e.g., during
      # git_clone-airgap-repo
      pushd "${main_dir}" &>/dev/null
        orphan_commit_repo_map "${repo_map}"
      popd &>/dev/null

      git_push_main repo_map.env ./

      extra_args=$#
      ;;

    git_clone-airgap-repo) # Clone a repo exported with `git export-repo`. This \
                           # is necessary because we do not want to update the \
                           # url's of the submodules
      local repo_map
      make_temp_path repo_map # auto-deleting file
      # The repo map's submodule URLs were corrected in git_import-repo
      git show __just_git_mirror_info_file:repo_map.env > "${repo_map}"
      git_clone_main "${repo_map}" ./

      extra_args=$#
      ;;

    # TODO Support iterating through all submodules too
    # TODO Generalize to support log_outgoing_commits too
    # TODO Support filtering by branches/remotes
    # TODO Move to just_git_functions
    git_unpushed-commits) # List unpushed commits on a branch
      if ! command -v ${GIT} >& /dev/null; then
        echo "Git not found, skipping listing of unpushed commits" >&2
        return 0
      fi

      local commits="$(log_unpushed_commits)"
      if [ "${commits}" != "" ]; then
        local ncommits="$(echo "${commits}" | grep -o '^\* commit' | wc -l | tr -d '[:space:]')"
        if [ "${ncommits}" -eq 0 ]; then
          : # pass
        elif [ "${ncommits}" -eq 1 ]; then
          echo "There is ${ncommits} unpushed commit:"
          echo
        elif [ "${ncommits}" -gt 1 ]; then
          echo "There are ${ncommits} unpushed commits:"
          echo
        fi
        echo "${commits}"
      fi
      ;;

    # TODO Move to just_git_functions
    git_make-remote-urls-pushable) # Change the remote urls to use the git@ \
                                   # syntax instead of https
      if ! command -v ${GIT} >& /dev/null; then
        echo "Git not found, skipping remote url conversion" >&2
        return 0
      fi

      # TODO Support iterating through all submodules
      make_remote_urls_pushable
      ;;

    *)
      plugin_not_found=1
      ;;
  esac
  return 0
}
