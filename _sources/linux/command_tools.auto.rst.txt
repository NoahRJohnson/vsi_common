=============
Command Tools
=============

.. default-domain:: bash

.. file:: command_tools.bsh

Set of functions to make using parsing and composing commands easier


:Arguments: ``$1``... - The names of the files being searched for
:Return Value: file_matches - array containing matches

Find files by searching up the parent tree

Searches for files to use. It starts by checking the current directory, and goes up. Just like git searches for a .git directory

.. function:: get_array_from_environment

:Arguments: * ``$1`` - Array variable name to store values in
            * ``$2`` - ``PREFIX`` used
            * ``$3`` - ``NAME`` used
            * ``[$4]`` - ``INSTANCE`` used. This argument is optional. If it is not specified, than the two patterns using ``INSTANCE`` are not checked.

The purpose of this function is to gather environment values from various locations that is advantageous in many situations. Get values from array ``{PREFIX}_{NAME}S``, values ``{PREFIX}_{NAME}_1``..., array ``{PREFIX}_{INSTANCE}_{NAME}S``, and values ``{PREFIX}_{INSTANCE}_{NAME}_1``... and stores them in the variable specified by ``$1``.

Since arrays cannot be exported, there are two different methods of getting environment variables.

.. function:: parse-generic

:Arguments: ``$1``.. - Arguments to be sent to some command
:Output: * command_args - Arguments to some command, before the subcommand (run, build, do_something, etc...)
         * subcommand - The subcommand specified
         * subcommand_args - Arguments for the specified subcommand

Parse a generic command's arguments and split up information (See OUTPUT). This supports a generic function that goes ``some command`` followed by arguments that start with ``-`` and take no additional arguments (``command_args``). Next an optional subcommand (``subcommand``) and those subcommand's arguments (``subcommand_args``).

This will only work in the simpliest of cases (e.g. ``singularity``). Cases like ``docker`` and other commands that have more complicated ``command_args`` choices, a specific version of this function needs to be written to handle all the argument cases.

Typically, in the calling function, you will define all the output variables as local, so that they are captured by the calling function only.

Original command can be thought of as:

.. code-block::

    some_command "${command_args[@]}" "${subcommand}" "${subcommand_args[@]}"

.. function:: compose_arguments

:Arguments: * [``$1``] - Name of array that will be inserted between ``command_args`` and ``subcommand``.
            * [``$2``] - Name of array that will be inserted between the ``subcommand`` and  command args and.
:Parameters: * ``cmd`` - The starting array of command arguments, starting with ``0``
             * ``command_args`` - Arguments to some command, before the subcommand (run, build, do_something, etc...)
             * ``subcommand`` - The subcommand specified
             * ``subcommand_args`` - Arguments for the specified subcommand

Appends arguemtns to the array ``cmd``. If ``cmd`` isn't defined at first, it is created an an empty array. If ``cmd`` is a string, it will be converted to a single element array, and then appended to.

.. rubric:: Example

.. code-block:: bash

   cmd=(${DRYRUN} foobar)
   CMD_ARGS=(--quiet --config "/tmp/foo bar.xml")
   MAGIC_ARGS=(-it --rm)
   subcommand=magic
   command_args=(--gpu)
   subcommand_args=(--do=something)

   compose_arguments CMD_ARGS MAGIC_ARGS
   declare -p cmd

   declare -a cmd=([0]="foobar" [1]="--gpu" [2]="--quiet" [3]="--config"
                   [4]="/tmp/foo bar.xml" [5]="magic" [6]="-it" [7]="--rm"
                   [8]="--do=something")

.. note::

   Even if the arguments' variables are a non-array variables, this will work. However they will always appear to be a single argument.

.. function:: parse_args

:Arguments: * ``$1`` - Name of variable to store how many arguments were parsed
            * ``$2`` - Option string, like ``-o`` or ``--output``
            * ``$3`` - The name of the variable that will store the result of the argument if used. Can be prefixed with ``+`` for an array, and postfixed with a ``:`` for "has an argument
            * [ ``$4...$N`` ] - Repeat ``$2`` and ``$3``
            * ``$N+1`` - Must be ``--`` to delineate the actual arguments are being passed in next
            * [``$N+2...``] - The argument to parse
:Outputs: * ``$!1`` - Store how many arguments are parsed after the ``--``, in the variable name specified in ``$1``
          * ``$3,$5,...`` - Stores the values in the corresponding variables/arrays

A simple argument parser, supporting some of the options that getopts supports

#. Only parses until an argument is encountered that does not match an argument. This is useful for subcommand parsing
#. Can support any arguments option, even if they do not start with ``-``, but that is ill advised
#. Does not support combining multiple one letter arguments into one argument
#. Supports the ``:`` postfix notation for "has an argument", add it to the storage name, not the option string
#. Does not support the ``::`` notation for "maybe has an argument"
#. Supports a ``+`` prefix notation on the storage variable name meaning the storage is an array, and values are appended to it.
#. If options do not have an argument, then they are set to 0 if unset, and +1 for each time it is set

.. rubric:: Example

.. code-block:: bash
   :caption: Here are two examples of using parse_args

   local nit_pick
   local rebuild_all
   parse_args extra_args -n nit_pick --nit nit_pick -E rebuild_all --all rebuild_all -- ${@+"${@}"}
   shift "${extra_args}"
   if [ "${nit_pick}" != "0" ]; then
     export SPHINXOPTS="${SPHINXOPTS-} -n"
   fi
   if [ "${rebuild_all}" != "0" ]; then
     export SPHINXOPTS="${SPHINXOPTS-} -E -a"
   fi

   # Sometimes you just need to add to extra_args because you already used it
   local compose_files=()
   local args_parsed
   parse_args args_parsed -f +compose_files: --file +compose_files: -- ${@+"${@}"}
   extra_args+="${args_parsed}"
   shift "${args_parsed}"
   ### Handle parsed arguments ###
   if [ "${#compose_files[@]}" != "0" ]; then
     local "${JUST_PROJECT_PREFIX}_SINGULAR_COMPOSE_FILES"
     dynamic_set_a "${JUST_PROJECT_PREFIX}_SINGULAR_COMPOSE_FILES" "${compose_files[@]}"
   fi

.. note:

   Variables are always overwritten, even if not used. A ``0`` for options without arguments, and an empty string for options that take arguments indicates the option was never used. However, arrays are always appeneded to.

.. warning::

   Don't use variable names that start with ``__parse_args``

.. function:: open_web_browser

Opens a file/link with a web browser

:Arguments: ``$1`` - The filename/link to be opened

On windows, uses the associated web browser. First tried the associated Linux web browser, ``google-chrome``, ``chromium-browser``, ``firefox``, then the associated macos web browser.

