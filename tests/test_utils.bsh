#!/usr/bin/env false bash

#*# tests/test_utils

. "${VSI_COMMON_DIR}/linux/string_tools.bsh"

#**
# ==============
# Test Utilities
# ==============
#
# .. default-domain:: bash
#
# .. file:: test_utils.bsh
#
# Utilities to help in test verifications
#**

ERR_C=$'\x1b[1;31m'
NC=$'\x1b[0m'
INFO_C=$'\x1b[33m'
HIGHLIGHT_C=$'\x1b[41;30m'

#**
# .. function:: check_a
#
# :Arguments: * ``$1`` - Array name
#             * [``$2``...] - Array values
# :Output: Return Value:
#
#             * ``0`` - Equal
#             * ``1`` - A value is not the same
#             * ``2`` - The array had less values than specified
#
# Check array values for unit tests
#
# .. seealso::
#   :func:`elements.bsh cmp_elements_a`
#**
function check_a()
{
  set +xv

  local check_a_indicies
  local check_a_name="${1}[@]"
  local check_a_values=(${!check_a_name+"${!check_a_name}"})
  check_a_name="${1}"
  eval 'check_a_indicies=("${!'$1'[@]}")'
  local check_a_index
  shift 1

  for check_a_index in ${check_a_values[@]+"${!check_a_values[@]}"}; do
    if [ $# -eq 0 ]; then
      echo "${ERR_C}ASSERT ERROR: Arrays differ${NC}" >&2
      echo "${check_a_name}=(${check_a_values[@]+${check_a_values[@]}})" >&2
      echo "Array had $((${#check_a_values[@]} - check_a_index)) too many values" >&2
      declare -p "${check_a_name}" >&2
      set -xv
      return 3
    fi
    if [ "${check_a_values[check_a_index]}" != "$1" ]; then
      echo "${ERR_C}ASSERT ERROR: Arrays differ${NC}" >&2
      echo "Element ${check_a_index} (${check_a_name}[${check_a_indicies[check_a_index]}]) is different:" >&2
      echo "${check_a_values[check_a_index]} != $1" >&2
      declare -p "${check_a_name}" >&2
      set -xv
      return 1
    fi
    shift 1
  done
  if [ $# -eq 0 ]; then
    set -xv
    return 0
  else
    echo "${ERR_C}ASSERT ERROR: Arrays differ${NC}" >&2
    echo "${check_a_name}=(${check_a_values[@]+${check_a_values[@]}})" >&2
    echo "Array had $# too few values" >&2
    declare -p "${check_a_name}" >&2
    set -xv
    return 2
  fi
}

#**
# .. function:: check_ra
#
# Regex version of :func:`check_a`
#**
function check_ra()
{
  set +xv
  local check_a_indicies
  local check_a_name="${1}[@]"
  local check_a_values=(${!check_a_name+"${!check_a_name}"})
  check_a_name="${1}"
  eval 'check_a_indicies=("${!'$1'[@]}")'
  local check_a_index
  shift 1

  for check_a_index in ${check_a_values[@]+"${!check_a_values[@]}"}; do
    if [ $# -eq 0 ]; then
      echo "${ERR_C}ASSERT ERROR: Arrays differ${NC}" >&2
      echo "${check_a_name}=(${check_a_values[@]+${check_a_values[@]}})" >&2
      echo "Array had $((${#check_a_values[@]} - check_a_index)) too many values" >&2
      declare -p "${check_a_name}" >&2
      set -xv
      return 3
    fi
    if [[ ! ${check_a_values[check_a_index]} =~ $1 ]]; then
      echo "${ERR_C}ASSERT ERROR: Arrays differ${NC}" >&2
      echo "Element ${check_a_index} (${check_a_name}[${check_a_indicies[check_a_index]}]) is different:" >&2
      echo "${check_a_values[check_a_index]} !=~ $1" >&2
      declare -p "${check_a_name}" >&2
      set -xv
      return 1
    fi
    shift 1
  done
  if [ $# -eq 0 ]; then
    set -xv
    return 0
  else
    echo "${ERR_C}ASSERT ERROR: Arrays differ${NC}" >&2
    echo "${check_a_name}=(${check_a_values[@]+${check_a_values[@]}})" >&2
    echo "Array had $# too few values" >&2
    declare -p "${check_a_name}" >&2
    set -xv
    return 2
  fi
}

#**
# .. function:: contiguous_a
#
# :Arguments: ``$1`` - Array name to test
# :Output: Return Value:
#
#             * ``0`` - Array is contiguous
#             * ``1`` - Array is not contiguous
#
# Check array values are contiguous for unit tests
#
# .. note::
#   Uses eval
#**
function contiguous_a()
{
  set +xv
  # Verify array is contiguous
  local contiguous_a_indicies=()
  local contiguous_a_i
  eval 'contiguous_a_indicies=("${!'$1'[@]}")'
  # Returns the result of check_a
  check_a contiguous_a_indicies $(seq 0 1 $((${#contiguous_a_indicies[@]}-1)))
  # check_a will set -xv for contiguous_a
}

function assert_str_eq
{
  set +xv
  if [ "${1}" != "${2}" ]; then
    local -i start=0
    local -i i
    local -i j

    echo "${ERR_C}ASSERT ERROR: Strings differ${NC}" >&2
    echo         "============================" >&2

    for ((i=0; i<${#1}; ++i)); do
      if [ "${1:i:1}" != "${2:i:1}" ]; then
        break
      fi
    done
    start="${i}"

    # This for loop matches the same notation as the previous for loop, but is
    # numerically identical to the following for loop, that is just cleaner
    # for ((i=${#1}-1, j=${#2}-1; i>start-1 && j>start-1; --i, --j)); do
    #   if [ "${1:i:1}" != "${2:j:1}" ]; then
    #     break
    #   fi
    # done
    # i+=1
    # j+=1

    for ((i=${#1}, j=${#2}; i>start && j>start; --i, --j)); do
      if [ "${1:i-1:1}" != "${2:j-1:1}" ]; then
        break
      fi
    done

    echo "${1::start}${HIGHLIGHT_C}${1:start:i-start}${NC}${1:i}" >&2
    echo "---------------------" >&2
    echo "${2::start}${HIGHLIGHT_C}${2:start:j-start}${NC}${2:j}" >&2
    set -xv
    return 1
  fi
  set -xv
}

function assert_test()
{
  set +xv
  if test "${@}"; then
    set -xv
    return 0
  else
    echo "${ERR_C}ASSERT ERROR: test${NC}" >&2
    echo         "==================" >&2
    echo "${INFO_C}FAILED:${NC} [ ${@} ]" >&2
    set -xv
    return 1
  fi
}

function assert_ansi_str_eq()
{
  set +xv
  local str1="$(strip_ansi "${1}")"
  local str2="$(strip_ansi "${2}")"

  assert_str_eq "${str1}" "${str2}"
  # assert_str_eq will set -xv
  return $?
}

function assert_sub_str()
{
  set +xv
  local str="${1}"
  local inner="${2}"

  if [[ ${str} = *"${inner}"* ]]; then
    set -xv
    return 0
  else
    echo "${ERR_C}ASSERT ERROR:${NC}" >&2
    echo         "=============" >&2
    echo "${str}" >&2
    echo "${INFO_C}does not contain the substring:${NC}" >&2
    echo "${inner}" >&2
    set -xv
    return 1
  fi
}

function assert_starts_with()
{
  set +xv
  local str="${1}"
  local start="${2}"

  if [[ ${str} = "${start}"* ]]; then
    set -xv
    return 0
  else
    echo "${ERR_C}ASSERT ERROR:${NC}" >&2
    echo         "=============" >&2
    echo "${str}" >&2
    echo "${INFO_C}does not start with:${NC}" >&2
    echo "${start}" >&2
    set -xv
    return 1
  fi
}

function assert_ends_with()
{
  set +xv
  local str="${1}"
  local end="${2}"

  if [[ ${str} = *"${end}" ]]; then
    set -xv
    return 0
  else
    echo "${ERR_C}ASSERT ERROR:${NC}" >&2
    echo         "=============" >&2
    echo "${str}" >&2
    echo "${INFO_C}does not end with:${NC}" >&2
    echo "${end}" >&2
    set -xv
    return 1
  fi
}

function assert_re_eq()
{
  set +xv
  if [[ ${1} =~ ${2} ]]; then
    set -xv
    return 0
  else
    echo "${ERR_C}ASSERT ERROR: regex eq${NC}" >&2
    echo         "======================" >&2
    echo "${INFO_C}FAILED:${NC} [[ ${1} =~ ${2} ]]" >&2
    set -xv
    return 1
  fi
}

#**
# .. function:: not
#
# :Arguments: ``$1``... - Command and arguments
# :Output: Return value
#
#     * ``0`` - On non-zero return code evaluation
#     * ``1`` - On zero return code
#
# Returns true only when the command fails
#
# Since ``!`` is ignored by "set -e", use :func:`not` instead. This is just a helper to make unittests look nice and not need extra ifs everywhere
#
# .. rubric:: Example
#
# .. code-block:: bash
#
#   # No good, always passes, even if ! true. If this is the last line of a
#   # function, you will be fooled into thinking it is working, because
#   # functions return the return value of the last line, by default.
#   # The "!" does set a non-zero return value, but does not trigger set -e,
#   # similar to [[ ]] in older versions of bash.
#   ! false
#
#   # good
#   not false
#   # equivalent to
#   if ! false; then
#     true
#   else
#     false
#   fi
#
# .. rubric:: Bugs
#
# Complex statements do not work, e.g. [, [[ and ((, etc...
#   For example, you should use
#
# .. code-block:: bash
#
#     [ ! -e /test ]
#
# |  instead of
#
# .. code-block:: bash
#
#     not [ -e /test ]
#
# |  In cases where this is not easily worked around, you can use
#
# .. code-block:: bash
#
#     not_s '[ -e /test ]'
#
# .. seealso::
#   :func:`not_s`
#**
not()
{
  set +xv
  local cmd="$1"
  shift 1
  if "${cmd}" ${@+"${@}"}; then
    set -xv
    return 1
  else
    set -xv
    return 0
  fi
}

# Testing this idea...
#**
# .. function:: not_s
#
# :Arguments: ``$1`` - Command/statement in a single string
# :Output: Return Value:
#
#             * ``0`` - On non-zero return code evaluation
#             * ``1`` - On zero return code
#
# Returns true only when the string version of command fails
#
# Since ``!`` is ignored by "set -e", use :func:`not` instead. This is just a helper to make unittests look nice and not need extra ifs everywhere.
#
# .. rubric:: Example
#
# .. code-block:: bash
#
#   x=test
#   y=t.st
#   not_s '[[ $x =~ $y ]]' # <-- notice single quotes.
#
# While the single quotes aren't necessary, they handle the more complicated situations more easily.
#
# .. note::
#   Uses eval
#
# .. seealso::
#   :func:`not`
#**
not_s()
{
  set +xv
  eval "if ${1}; then
          set-xv
          return 1
        else
          set -xv
          return 0
        fi"
}