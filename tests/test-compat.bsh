#!/usr/bin/env bash

if [ -z ${VSI_COMMON_DIR+set} ]; then
  VSI_COMMON_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.."; pwd)"
fi

source "${VSI_COMMON_DIR}/tests/testlib.bsh"
source "${TESTLIB_DIR}/test_utils.bsh"
source "${VSI_COMMON_DIR}/linux/compat.bsh"

begin_test "Sed flag"
(
  setup_test

  unset sed VSI_SED_COMPAT
  OSTYPE=darwin14 load_vsi_compat
  [ "${sed_flag_rE}" = "E" ]
  [ "${sed_flag_i}" = "i ''" ]
  unset OSTYPE

  OS=Windows_NT load_vsi_compat
  [ "${sed_flag_rE}" = "r" ]
  [ "${sed_flag_i}" = "i" ]
  unset OS

  function sed()
  {
    echo "sed (GNU sed) 4.5" # stdout
  }
  unset VSI_SED_COMPAT
  load_vsi_compat
  [ "${sed_flag_rE}" = "r" ]


  function sed()
  {
    return 1
  }
  unset VSI_SED_COMPAT
  load_vsi_compat
  [ "${sed_flag_rE}" = "E" ]

  # Test manual override
  VSI_SED_COMPAT=gnu
  load_vsi_compat
  [ "${sed_flag_rE}" = "r" ]
  [ "${sed_flag_i}" = "i" ]

  VSI_SED_COMPAT=bsd
  load_vsi_compat
  [ "${sed_flag_rE}" = "E" ]
  [ "${sed_flag_i}" = "i" ]
)
end_test

# The rest of these compatibility tests are performed by actually using the flags
# to see if the test passes or fails, instead of mocking. CI will test all versions,
# and thus thoroughly test this

begin_test "Date flag"
(
  setup_test

  if [ "${date_feature_nanoseconds}" = "0" ]; then
    assert_regex_eq "$(date +%N)" '^[0-9]{9}$'
  else
    not assert_regex_eq "$(date +%N)" '^[0-9]{9}$'
  fi
)
end_test

begin_test "Bash flag"
(
  setup_test

  x1=(foo bar)
  assert_str_eq "$(declare -p x1)" "declare -a x1=${bash_declare_array_quote}([0]=\"foo\" [1]=\"bar\")${bash_declare_array_quote}"

  if [ "${bash_feature_parameter_transformation}" = "0" ]; then
    assert_regex_eq "${BASH_VERSINFO@a}" '^[ar]*$'
  fi

  if [ "${bash_feature_declare_name_reffing}" = "0" ]; then
    declare -n y2=x1
  else
    not declare -n y2=x1
  fi

  z3=(11 22)
  if [ "${bash_feature_printf_array_assignment}" = "0" ]; then
    printf -v z3[2] '%s' 33
    assert_array_values z3 11 22 33
  else
    not printf -v z3[2] '%s' 33
  fi

  if [ "${bash_feature_associative_array}" = "0" ]; then
    declare -A foo4
    foo4[var]=15
  else
    not declare -A foo4
  fi

  d5=$'foo\tbar'
  re5='\t'
  if [ "${bash_regex_special_characters_non_literal}" = "0" ]; then
    assert_regex_eq "${d5}" "${re5}"
  else
    not assert_regex_eq "${d5}" "${re5}"
  fi

  arr6=(11 22 33 44)
  ans1_6=(33 44)
  ans2_6=("33 44")
  OLD_IFS="${IFS}"
  IFS=x
  arr2_6=("${arr6[@]:2}")
  if [ "${bash_bug_ifs_array_slice_expansion}" = "0" ]; then
    assert_array_eq arr2_6 ans2_6
  else
    assert_array_eq arr2_6 ans1_6
  fi
  IFS="${OLD_IFS}"

  declare -a some_var7
  if [ "${bash_bug_declare_fails_local_declared_unset_variable}" = "0" ]; then
    not declare -p some_var7
  else
    declare -p some_var7
  fi

  if [ "${bash_feature_declare_global}" = "0" ]; then
    declare -g foo8
  else
    not declare -g foo8
  fi

  if [ "${bash_feature_allocate_file_descriptor}" = "0" ]; then
    (exec {x9}>&2) 2>/dev/null
  else
    not_s '(exec {x}>&1) 1>/dev/null'
  fi

  function foo_10()
  {
    :
  }
  ans_10='foo_10 *\(\) *
\{ *
 *: *
\} *'

  if [ "${bash_feature_declare_print_function}" = "0" ]; then
    declare -pf foo_10
    assert_regex_eq "$(declare -pf foo_10)" "${ans_10}"
  else
    not declare -pf foo_10
  fi

  export x_11=12
  function foo_11()
  {
    local x_11
    declare -p x_11 || :
    compgen -A export x_11
    bash -c "declare -p x_11 || :"
  }

  nl=$'\n'
  ans_11=
  if [ "${bash_bug_declare_fails_local_declared_unset_variable}" = "1" ]; then
    ans_11="declare -x x_11${bash_declared_unset_value}${nl}"
  fi
  ans_11+=$'x_11'
  if [ "${bash_bug_local_shadow_exported_variable}" = "1" ]; then
    ans_11+="${nl}declare -x x_11=\"12\""
  fi

  # This bug won't manifest when the function is directly called via $(), use a file proxy
  assert_str_eq "$("${TESTLIB_DIR}/aux_compat_1.bsh")" "${ans_11}"

  if [ "${bash_bug_substitute_empty_funcname}" = "0" ]; then
    [ " ""${FUNCNAME[@]+FOO}" = " FOO" ]
  else
    [ " ""${FUNCNAME[@]+FOO}" != " FOO" ]
  fi
)
end_test

[ "${bash_feature_parameter_transformation}" = "1" ] || skip_next_test
begin_required_fail_test "Fail bash parameter transformation"
(
  setup_test
  begin_fail_zone
  echo "${BASH_VERSINFO@a}"
)
end_test
