#!/usr/bin/env bash
# TODO Disable any gitconfig settings

. "$(dirname "${BASH_SOURCE[0]}")/../testlib.bsh"
VSI_COMMON_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/../.."; pwd)"

. "${VSI_COMMON_DIR}/linux/requirements.bsh"
. "${VSI_COMMON_DIR}/linux/just_git_airgap_repo.bsh"

# These tests chain together, so no point in continuing after one breaks
TESTLIB_STOP_AFTER_FAILS=1
unset TESTLIB_SKIP_TESTS TESTLIB_RUN_SINGLE_TEST

if ! git lfs &> /dev/null; then
  TESTLIB_SKIP_TESTS='.*'
fi

function setup()
{
  # Easier way to take care of committers on vanilla install
  export GIT_COMMITTER_NAME='Foo Bar'
  export GIT_AUTHOR_NAME='Foo Bar'
  export GIT_COMMITTER_EMAIL='foo.bar@example.com'
  export GIT_AUTHOR_EMAIL='foo.bar@example.com'

  VSI_COMMON_URL="${TRASHDIR}/git/VisionSystemsInc/vsi_common.git" # bare repo
  RECIPES_URL="${TRASHDIR}/git/VisionSystemsInc/docker_recipes.git" # bare repo
  PRETEND_URL="${TRASHDIR}/git/pretend_repo.git" # bare repo
  BUILD_REPO="${TRASHDIR}/build"
  PREP_DIR="${TRASHDIR}/pretend_prep"
  TRANSFER_DIR="${TRASHDIR}/transfer"
  AIRGAP_MIRROR_DIR="${TRASHDIR}/airgap/mirror"
  AIRGAP_CLONE_DIR="${TRASHDIR}/airgap/clone"

  mkdir -p "${VSI_COMMON_URL}"
  mkdir -p "${RECIPES_URL}"
  mkdir -p "${PRETEND_URL}"
  mkdir -p "${BUILD_REPO}"
  mkdir -p "${TRANSFER_DIR}"
  mkdir -p "${AIRGAP_CLONE_DIR}"
}

begin_test "Part 1 - Setup test repo"
(
  setup_test

  # Create faux-urls for the repo and its submodules
  pushd "${VSI_COMMON_URL}" &> /dev/null
    # This only works right, because all branches appear to be "topic" branches,
    # so a push --mirror (once) will do what I want. Doesn't work well with more
    # complexities like lfs
    git clone --mirror "${VSI_COMMON_DIR}" . # This is the real VSI_COMMON_DIR
  popd &> /dev/null

  # In this case, it is lucky that the recipes submodule is stored as a relative
  # URL; otherwise, we'd have to modify the parent project
  pushd "${RECIPES_URL}" &> /dev/null
    # This only works right, because all branches appear to be "topic" branches,
    # so a push --mirror (once) will do what I want. Doesn't work well with more
    # complexities like lfs
    git clone --mirror "${VSI_COMMON_DIR}"/docker/recipes .
  popd &> /dev/null

  # Main repo
  mkdir -p "${BUILD_REPO}"
  pushd "${BUILD_REPO}" &> /dev/null
    git init
    touch readme
    git add readme
    git commit -m "Initial commit"

    git submodule add "${VSI_COMMON_URL}" vsi_common
    pushd vsi_common &> /dev/null
      git submodule update --init --recursive
      # TODO remove once this branch is merged into master
      # RE actually, it seems we are already on this branch
      git checkout sgrichar_git_airgap
    popd &> /dev/null
    git add vsi_common

    git commit -m "Added submodules"
  popd &> /dev/null
  mkdir -p "${PRETEND_URL}"
  pushd "${PRETEND_URL}" &> /dev/null
    git clone --mirror "${BUILD_REPO}" .
  popd &> /dev/null
)
end_test

begin_test "Part 2 - Initial mirror"
(
  setup_test

  pushd "${BUILD_REPO}" &> /dev/null
    . "${BUILD_REPO}/vsi_common/linux/just_git_airgap_repo.bsh"
    # FIXME omitting JUST_VERSION did not cause this test to fail, even though
    # it results in an unbound variable
    VSI_COMMON_DIR="${BUILD_REPO}"/vsi_common JUST_VERSION=1.0 JUST_WORKING_DIR="${PWD}" \
        relocate_git_defaultify git_export-repo "${PRETEND_URL}" master "${PREP_DIR}"
  popd &> /dev/null
)
end_test

# REVIEW why is this not in Part 3
PREP_FILE=("${PREP_DIR}"/transfer_*.tgz)

begin_test "Part 3 - Simulating transfer"
(
  setup_test

  pushd "${TRANSFER_DIR}" &> /dev/null
    tar zxf "${PREP_FILE[0]}"
  popd &> /dev/null
)
end_test

begin_test "Part 4 - Pushing to mirror"
(
  setup_test

  for d in pretend_repo.git vsi_common.git recipes.git; do
    mkdir -p "${AIRGAP_MIRROR_DIR}/${d}"
    pushd "${AIRGAP_MIRROR_DIR}/${d}" &> /dev/null
      git init --bare
    popd &> /dev/null
  done

  pushd "${TRANSFER_DIR}" &> /dev/null
    source setup.env # Sets VSI_COMMON_DIR to "${TRANSFER_DIR}"/.vsi_common
    source "${VSI_COMMON_DIR}/linux/just_git_airgap_repo.bsh"
    # TODO use compat.bsh flag
    sed -i '' -e 's|^JUST_GIT_AIRGAP_MIRROR_URL=$|JUST_GIT_AIRGAP_MIRROR_URL="'"${AIRGAP_MIRROR_DIR}"'"|' repo_map.env
    JUST_WORKING_DIR="${PWD}" relocate_git_defaultify git_import-repo
  popd &> /dev/null
)
end_test

begin_test "Part 5 - Cloning from mirror"
(
  setup_test

  pushd "${AIRGAP_CLONE_DIR}" &> /dev/null
    git clone "${AIRGAP_MIRROR_DIR}"/pretend_repo.git .

    # per just_git_airgap_repo:print_git_airgap_submodule_update
    source /dev/stdin <<< "$(git show origin/__just_git_mirror_info_file:repo_map.env 2>/dev/null)"
    git_airgap_submodule_update vsi_common

    source "${AIRGAP_CLONE_DIR}/vsi_common/linux/just_git_airgap_repo.bsh"

    JUST_WORKING_DIR="${PWD}" relocate_git_defaultify git_clone-airgap-repo
  popd &> /dev/null

  # NOTE Unfortunately, the main repo is dealt with separately from submodules.
  # Be sure to test both
  [[ "$(git -C "${AIRGAP_CLONE_DIR}" rev-parse HEAD)" == "$(git -C "${VSI_COMMON_REPO}" rev-parse HEAD)" ]]
  [[ "$(git -C "${AIRGAP_CLONE_DIR}"/docker/recipes rev-parse HEAD)" == "$(git -C "${VSI_COMMON_REPO}"/docker/recipes rev-parse HEAD)" ]]
)
end_test

begin_test "Part 6 - Check for unpushed tracked commits in submodules"
(
  setup_test

  ##################################
  #              SETUP             #
  ##################################

  BUILD_REPO1="${TESTDIR}"/build_repo
  PRETEND_URL1="${TESTDIR}/git/pretend_repo" # bare repo
  if [ "${OS-}" = "Windows_NT" ]; then
    DIFFICULT_PATH1='diff  i cult'
  else
    DIFFICULT_PATH1=$'diff  i \t cult'
  fi
  DIFFICULT_NAME1='difficult submod'


  # Sub sub module
  mkdir -p "${BUILD_REPO1}_sub_sub"
  pushd "${BUILD_REPO1}_sub_sub" &> /dev/null
    git init .
    touch readme_sub_sub
    git add readme_sub_sub
    git commit -m "Initial commit"
  popd &> /dev/null
  mkdir -p "${PRETEND_URL1}_sub_sub"
  pushd "${PRETEND_URL1}_sub_sub" &> /dev/null
    # This only works right, because all branches appear to be "topic" branches,
    # so a push --mirror (once) will do what I want. Doesn't work well with more
    # complexities like lfs
    git clone --mirror "${BUILD_REPO1}_sub_sub" .
    # git init --bare .
    # cd "${BUILD_REPO1}_sub_sub"
    # git remote add origin "${PRETEND_URL1}_sub_sub"
    # git push origin --mirror
  popd &> /dev/null

  # Sub module
  mkdir -p "${BUILD_REPO1}_sub"
  pushd "${BUILD_REPO1}_sub" &> /dev/null
    git init .
    touch readme_sub
    git add readme_sub
    git submodule add "${PRETEND_URL1}_sub_sub" "a_sub_sub_module"
    git commit -m "Initial commit"
  popd &> /dev/null
  mkdir -p "${PRETEND_URL1}_sub"
  pushd "${PRETEND_URL1}_sub" &> /dev/null
    git clone --mirror "${BUILD_REPO1}_sub" .
    # git init --bare .
    # cd "${BUILD_REPO1}_sub"
    # git remote add origin "${PRETEND_URL1}_sub"
    # git push origin --mirror
  popd &> /dev/null

  # Main Repo

  # sm_path (sm_name, if different)                URL
  # ./                                             "${PRETEND_URL1}"
  # ./"${DIFFICULT_PATH1}" ("${DIFFICULT_NAME1}")  "${PRETEND_URL1}_sub"
  # ./"${DIFFICULT_PATH1}/a_sub_sub_module"        "${PRETEND_URL1}_sub_sub"
  #
  # NOTE each repo is created in a respective ${BUILD_REPO1}"_* repo and mirror
  # pushed to "${PRETEND_URL1}"_*

  mkdir -p "${PRETEND_URL1}"
  pushd "${PRETEND_URL1}" &> /dev/null
    git init --bare .
  popd &> /dev/null
  mkdir -p "${BUILD_REPO1}"
  pushd "${BUILD_REPO1}" &> /dev/null
    git init
    touch readme
    git add readme
    git commit -m "Initial commit"
    git remote add origin "${PRETEND_URL1}"
    git push origin master

    git submodule add --name "${DIFFICULT_NAME1}" "${PRETEND_URL1}_sub" "${DIFFICULT_PATH1}"
    # Git itself can't handle newlines, although the config file actually can
    # escape them. This is a PURE git bug, plain and simple.
    # This won't actually create a newline in the name, it just ignores it
    # git submodule add https://github.com/visionsystemsinc/vsi_common $'  foo\tar\n'
    # This will.
    # git mv $'  diff  i \t cult' $' \n diff  i \t cult'
    # However, at random this gives permission denied errors, good thing I don't need it...
    git submodule update --init --recursive
    git commit -m "Added submodules"

    pushd "${DIFFICULT_PATH1}" &> /dev/null
      pushd a_sub_sub_module &> /dev/null
        git checkout master
        touch a_sub_sub_file
        git add a_sub_sub_file
        git commit -m "Second commit"
      popd &> /dev/null

      git add a_sub_sub_module
      git commit -m "update (sub) sub module"
    popd &> /dev/null

    git add "${DIFFICULT_PATH1}"
    git commit -m "Updated submodules"
  popd &> /dev/null

  #################################
  #              TEST             #
  #################################

  expected1="WARNING The commit tracked by the parent repository of the
submodule, '${DIFFICULT_NAME1}', has not been pushed to the
remote URL tracked by the parent repository:
  ${PRETEND_URL1}_sub

WARNING The commit tracked by the parent repository of the
submodule, 'a_sub_sub_module', has not been pushed to the
remote URL tracked by the parent repository:
  ${PRETEND_URL1}_sub_sub" # NOTE there is actually a trailing newline here...

  expected2="WARNING The commit tracked by the parent repository of the
submodule, 'a_sub_sub_module', has not been pushed to the
remote URL tracked by the parent repository:
  ${PRETEND_URL1}_sub_sub" # NOTE there is actually a trailing newline here...

  pushd "${BUILD_REPO1}" &> /dev/null
    rv=0
    output="$(git_push_check_recursive_submodules)" || rv=$?
    [ "${rv}" -eq 1 ] && [ "${output}" = "${expected1}" ]

    # Push the changes to the submodule
    pushd "${DIFFICULT_PATH1}" &> /dev/null
      git push origin master
    popd &> /dev/null
    rv=0
    output="$(git_push_check_recursive_submodules)" || rv=$?
    [ "${rv}" -eq 1 ] && [ "${output}" = "${expected2}" ]

    # Push the changes to the sub submodule
    pushd "${DIFFICULT_PATH1}"/a_sub_sub_module &> /dev/null
      git push origin master
    popd &> /dev/null
    rv=0
    output="$(git_push_check_recursive_submodules)" || rv=$?
    [ "${rv}" -eq 0 ] && [ "${output}" = "" ]

    # FIXME We are not testing whether the top-level repo has
    # unpushed changes for a given remote & branch
  popd &> /dev/null
)
end_test

# UNIT TEST test the guided target

# TEST 1 test the git functionality based on a single repo with a number of commits/branches
# TEST 3 test git_push_check_recursive_submodules
