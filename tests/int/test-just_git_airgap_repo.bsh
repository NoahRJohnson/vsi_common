#!/usr/bin/env bash

. "$(dirname "${BASH_SOURCE[0]}")/../testlib.bsh"
VSI_COMMON_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/../.."; pwd)"

. "${VSI_COMMON_DIR}/linux/requirements.bsh"
. "${VSI_COMMON_DIR}/linux/just_git_airgap_repo.bsh"

# These tests chain together, so no point in continuing after one breaks
TESTLIB_STOP_AFTER_FAILS=1
unset TESTLIB_SKIP_TESTS TESTLIB_RUN_SINGLE_TEST

if ! git lfs &> /dev/null; then
  TESTLIB_SKIP_TESTS='.*'
fi

function setup()
{
  # Easier way to take care of committers on vanilla install
  export GIT_COMMITTER_NAME='Foo Bar'
  export GIT_AUTHOR_NAME='Foo Bar'
  export GIT_COMMITTER_EMAIL='foo.bar@example.com'
  export GIT_AUTHOR_EMAIL='foo.bar@example.com'

  VSI_COMMON_URL="${TRASHDIR}/VisionSystemsInc/vsi_common.git" # bare repo
  RECIPES_URL="${TRASHDIR}/VisionSystemsInc/docker_recipes.git" # bare repo
  VSI_COMMON_REPO="${TRASHDIR}/vsi_common"
  VSI_COMMON_PREP="${TRASHDIR}/vsi_common_prep"
  TRANSFER_DIR="${TRASHDIR}/transfer"
  MIRROR_DIR="${TRASHDIR}/mirror"
  CLONE_DIR="${TRASHDIR}/clone"

  mkdir -p "${VSI_COMMON_URL}"
  mkdir -p "${RECIPES_URL}"
  mkdir -p "${VSI_COMMON_REPO}"
  mkdir -p "${TRANSFER_DIR}"
  mkdir -p "${CLONE_DIR}"
}

begin_test "Part 1 - Setup test repo"
(
  setup_test

  # Create faux-urls for the repo and its submodules
  pushd "${VSI_COMMON_URL}" &> /dev/null
    # This only works right, because all branches appear to be "topic" branches,
    # so a push --mirror (once) will do what I want. Doesn't work well with more
    # complexities like lfs
    git clone --mirror "${VSI_COMMON_DIR}" . # This is the real VSI_COMMON_DIR
  popd &> /dev/null

  # In this case, it is lucky that the recipes submodule is stored as a relative
  # URL; otherwise, we'd have to modify the parent project
  pushd "${RECIPES_URL}" &> /dev/null
    # This only works right, because all branches appear to be "topic" branches,
    # so a push --mirror (once) will do what I want. Doesn't work well with more
    # complexities like lfs
    git clone --mirror "${VSI_COMMON_DIR}"/docker/recipes .
  popd &> /dev/null

  pushd "${VSI_COMMON_REPO}" &> /dev/null
    git clone "${VSI_COMMON_URL}" .
    git submodule update --init --recursive
  popd &> /dev/null
)
end_test

begin_test "Part 2 - Initial mirror"
(
  setup_test

  pushd "${VSI_COMMON_REPO}" &> /dev/null
  ( # Put in subprocess because we are source'ing just_git_airgap_repo.bsh
    source setup.env
    source "${VSI_COMMON_REPO}/linux/just_git_airgap_repo.bsh"
    # FIXME omitting JUST_VERSION did not cause this test to fail, even though
    # it results in an unbound variable
    JUST_VERSION=1.0 JUST_WORKING_DIR="${PWD}" relocate_git_defaultify git_export-repo \
        "${VSI_COMMON_URL}" master "${VSI_COMMON_PREP}"
  )
  popd &> /dev/null
)
end_test

# REVIEW why is this not in Part 3
PREP_FILE=("${VSI_COMMON_PREP}"/transfer_*.tgz)

begin_test "Part 3 - Simulating transfer"
(
  setup_test

  pushd "${TRANSFER_DIR}" &> /dev/null
    tar zxf "${PREP_FILE[0]}"
  popd &> /dev/null
)
end_test

begin_test "Part 4 - Pushing to mirror"
(
  setup_test

  for d in vsi_common.git recipes.git; do
    mkdir -p "${MIRROR_DIR}/${d}"
    pushd "${MIRROR_DIR}/${d}" &> /dev/null
      git init --bare
    popd &> /dev/null
  done

  pushd "${TRANSFER_DIR}" &> /dev/null
  ( # Put in subprocess because we are source'ing setup.env
      source setup.env # Sets VSI_COMMON_DIR to "${TRANSFER_DIR}"/.vsi_common
      source "${VSI_COMMON_DIR}/linux/just_git_airgap_repo.bsh"
      # TODO use compat.bsh flag
      sed -i '' -e 's|^JUST_GIT_AIRGAP_MIRROR_URL=$|JUST_GIT_AIRGAP_MIRROR_URL="'"${MIRROR_DIR}"'"|' repo_map.env
      JUST_WORKING_DIR="${PWD}" relocate_git_defaultify git_import-repo
  )
  popd &> /dev/null
)
end_test

begin_test "Part 6 - Cloning from mirror"
(
  setup_test

  pushd "${CLONE_DIR}" &> /dev/null
  ( # Put in subprocess because we are source'ing setup.env
    git clone "${MIRROR_DIR}"/vsi_common.git .
    # TODO remove once this branch is merged into master
    git checkout sgrichar_git_airgap

    source setup.env # Sets VSI_COMMON_DIR to "${CLONE_DIR}"
    source "${VSI_COMMON_DIR}/linux/just_git_airgap_repo.bsh"

    # If vsi_common were a submodule, it would require this:
    #(
    #  # per just_git_airgap_repo:print_git_airgap_submodule_update
    #  source /dev/stdin <<< "$(git show origin/__just_git_mirror_info_file:repo_map.env 2>/dev/null)"
    #  git_airgap_submodule_update external/vsi_common
    #)

    JUST_WORKING_DIR="${PWD}" relocate_git_defaultify git_clone-airgap-repo
  )
  popd &> /dev/null

  [[ "$(git -C "${CLONE_DIR}" rev-parse HEAD)" == "$(git -C "${VSI_COMMON_REPO}" rev-parse HEAD)" ]]
  [[ "$(git -C "${CLONE_DIR}"/docker/recipes rev-parse HEAD)" == "$(git -C "${VSI_COMMON_REPO}"/docker/recipes rev-parse HEAD)" ]]
)
end_test

# UNIT TEST test the guided target

# TEST 1 test the git functionality based on a single repo with a number of commits/branches
# TEST 2 just git export-repo, move archive, import-repo, clone-submodules-recursively
# TEST 3 test git_push_check_recursive_submodules (most complicated)
